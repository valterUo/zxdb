{
  "version": 1,
  "type": "collection",
  "title": "Labeling queries - ZXdb",
  "items": [
    {
      "title": "Hadamard cancellation labeling query",
      "description": "",
      "query": {
        "code": {
          "value": "MATCH path = (start)-[:Wire*2..6]-(end)\r\nWHERE \r\n  // Even length path\r\n  size(relationships(path)) % 2 = 0\r\n  // All edges are unmarked Hadamard edges\r\n  AND ALL(edge IN relationships(path) WHERE edge.t = 2 AND edge.pattern_id IS NULL)\r\n  // All intermediate nodes are unmarked identity Z-spiders\r\n  AND ALL(node IN nodes(path)[1..-1] \r\n          WHERE node.t = 1 \r\n          AND node.phase % 2 = 0 \r\n          AND degree(node) = 2 \r\n          AND node.pattern_id IS NULL)\r\n  // Only process unmarked start/end nodes\r\n  AND start.pattern_id IS NULL \r\n  AND end.pattern_id IS NULL\r\n\r\n// Order by path length (longest first) and node IDs for consistency\r\nWITH path, nodes(path) as path_nodes, relationships(path) as path_edges\r\nORDER BY length(path) DESC, id(nodes(path)[0]), id(nodes(path)[-1])\r\nLIMIT 1\r\n\r\n// Mark this pattern with unique ID\r\nWITH path_nodes, path_edges, randomUUID() as pattern_id\r\n\r\n// Mark all edges in the path\r\nUNWIND path_edges AS edge\r\nSET edge.pattern_id = pattern_id\r\n\r\n// Mark all intermediate nodes in the path\r\nWITH path_nodes[1..-1] as intermediate_nodes, pattern_id, path_edges\r\nUNWIND intermediate_nodes AS node\r\nSET node.pattern_id = pattern_id\r\n\r\nRETURN DISTINCT pattern_id, length(path_edges) as path_length"
        },
        "params": {}
      },
      "style": {
        "code": {
          "value": "// A palette of colors used to color distinct node labels\nDefine(COLOR_PALETTE, AsArray(\n  #DD2222, #FB6E00, #FFC500, #720096,\n  #5E4FA2, #3288BD, #66C2A5, #ABDDA4,\n  #E6F598, #FEE08B, #D53E4F, #9E0142\n))\nDefine(COLOR_PALETTE_ITER, AsIterator(COLOR_PALETTE))\n\n// If there are no palette colors to use, use random colors instead\nDefine(RandomColor, Function(RGB(RandomInt(255), RandomInt(255), RandomInt(255))))\nDefine(GetNextColor, Function(\n  Coalesce(Next(COLOR_PALETTE_ITER), RandomColor())\n))\n\n// Cache map to keep a selected color for each node label\nDefine(ColorByLabel, AsMap())\nDefine(GetColorByLabel, Function(labels, Coalesce(\n  Get(ColorByLabel, labels),\n  Set(ColorByLabel, labels, GetNextColor())\n)))\nDefine(JoinLabels, Function(labels, Join(Sort(labels), \":\")))\n\n// Baseline node style that will be applied to every single node\n@NodeStyle {\n  Define(COLOR, GetColorByLabel(JoinLabels(Labels(node))))\n\n  size: 6\n  color: COLOR\n  color-hover: Lighter(COLOR)\n  color-selected: Darker(COLOR)\n  border-width: 0.6\n  border-color: #1D1D1D\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Overwrite node text with the node label if defined\n@NodeStyle Greater(Size(Labels(node)), 0) {\n  label: Format(\":{}\", Join(Labels(node), \" :\"))\n}\n\n// Overwrite node text with the property \"name\" if defined\n@NodeStyle HasProperty(node, \"name\") {\n  label: AsText(Property(node, \"name\"))\n}\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node label\n// @NodeStyle HasLabel(node, \"MyCustomLabel\") {\n//   color: black\n// }\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node property\n// @NodeStyle HasProperty(node, \"my_property_name\") {\n//   color: black\n//   label: AsText(Property(node, \"my_property_name\"))\n// }\n\nDefine(LATITUDE_FIELD, \"lat\")\nDefine(LONGITUDE_FIELD, \"lng\")\n\n// In the case of numeric latitude and longitude properties, set them up for a switch to a map view\n@NodeStyle And(IsNumber(Property(node, LATITUDE_FIELD)), IsNumber(Property(node, LONGITUDE_FIELD))) {\n  latitude: Property(node, LATITUDE_FIELD)\n  longitude: Property(node, LONGITUDE_FIELD)\n}\n\n// Baseline edge style that will be applied to every single edge\n@EdgeStyle {\n  color: #999999\n  color-hover: #1D1D1D\n  color-selected: #1D1D1D\n  width: 0.3\n  width-hover: 0.9\n  width-selected: 0.9\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Show edge text only if there is a small number of edges in the view\n@EdgeStyle Less(EdgeCount(graph), 30) {\n  label: Type(edge)\n}\n\n// In case of a map view, set the default tile layer\n@ViewStyle.Map {\n  tile-layer: \"light\"\n}\n\n// Canvas background color\n@ViewStyle {\n  background-color: #FFFFFF00\n}\n"
        },
        "title": "System Style"
      }
    },
    {
      "title": "Spider labeling query green",
      "description": "",
      "query": {
        "code": {
          "value": "// Label Z-wire patterns in order of decreasing length\r\nCALL {\r\n  // 4-edge paths first\r\n  MATCH path = (start)-[:Wire*4]-(end)\r\n  WHERE\r\n    ALL(edge IN relationships(path) WHERE edge.t = 1 AND edge.pattern_id IS NULL) AND\r\n    ALL(node IN nodes(path) WHERE node.t = 1 AND node.pattern_id IS NULL) AND\r\n    id(start) < id(end)\r\n  WITH DISTINCT path, start, end,\r\n       nodes(path) AS path_nodes,\r\n       relationships(path) AS path_edges\r\n  WHERE ALL(x IN path_nodes WHERE x.pattern_id IS NULL)\r\n    AND ALL(e IN path_edges WHERE e.pattern_id IS NULL)\r\n  WITH path_nodes, path_edges, randomUUID() AS pattern_id\r\n  FOREACH (edge IN path_edges | SET edge.pattern_id = pattern_id)\r\n  FOREACH (node IN path_nodes | SET node.pattern_id = pattern_id)\r\n  RETURN COUNT(DISTINCT pattern_id) AS labeled_4\r\n}\r\nCALL {\r\n  // Then 3-edge paths\r\n  MATCH path = (start)-[:Wire*3]-(end)\r\n  WHERE\r\n    ALL(edge IN relationships(path) WHERE edge.t = 1 AND edge.pattern_id IS NULL) AND\r\n    ALL(node IN nodes(path) WHERE node.t = 1 AND node.pattern_id IS NULL) AND\r\n    id(start) < id(end)\r\n  WITH DISTINCT path, start, end,\r\n       nodes(path) AS path_nodes,\r\n       relationships(path) AS path_edges\r\n  WHERE ALL(x IN path_nodes WHERE x.pattern_id IS NULL)\r\n    AND ALL(e IN path_edges WHERE e.pattern_id IS NULL)\r\n  WITH path_nodes, path_edges, randomUUID() AS pattern_id\r\n  FOREACH (edge IN path_edges | SET edge.pattern_id = pattern_id)\r\n  FOREACH (node IN path_nodes | SET node.pattern_id = pattern_id)\r\n  RETURN COUNT(DISTINCT pattern_id) AS labeled_3\r\n}\r\nCALL {\r\n  // Then 2-edge paths\r\n  MATCH path = (start)-[:Wire*2]-(end)\r\n  WHERE\r\n    ALL(edge IN relationships(path) WHERE edge.t = 1 AND edge.pattern_id IS NULL) AND\r\n    ALL(node IN nodes(path) WHERE node.t = 1 AND node.pattern_id IS NULL) AND\r\n    id(start) < id(end)\r\n  WITH DISTINCT path, start, end,\r\n       nodes(path) AS path_nodes,\r\n       relationships(path) AS path_edges\r\n  WHERE ALL(x IN path_nodes WHERE x.pattern_id IS NULL)\r\n    AND ALL(e IN path_edges WHERE e.pattern_id IS NULL)\r\n  WITH path_nodes, path_edges, randomUUID() AS pattern_id\r\n  FOREACH (edge IN path_edges | SET edge.pattern_id = pattern_id)\r\n  FOREACH (node IN path_nodes | SET node.pattern_id = pattern_id)\r\n  RETURN COUNT(DISTINCT pattern_id) AS labeled_2\r\n}\r\nCALL {\r\n  // Finally 1-edge paths\r\n  MATCH path = (start)-[:Wire*1]-(end)\r\n  WHERE\r\n    ALL(edge IN relationships(path) WHERE edge.t = 1 AND edge.pattern_id IS NULL) AND\r\n    ALL(node IN nodes(path) WHERE node.t = 1 AND node.pattern_id IS NULL) AND\r\n    id(start) < id(end)\r\n  WITH DISTINCT path, start, end,\r\n       nodes(path) AS path_nodes,\r\n       relationships(path) AS path_edges\r\n  WHERE ALL(x IN path_nodes WHERE x.pattern_id IS NULL)\r\n    AND ALL(e IN path_edges WHERE e.pattern_id IS NULL)\r\n  WITH path_nodes, path_edges, randomUUID() AS pattern_id\r\n  FOREACH (edge IN path_edges | SET edge.pattern_id = pattern_id)\r\n  FOREACH (node IN path_nodes | SET node.pattern_id = pattern_id)\r\n  RETURN COUNT(DISTINCT pattern_id) AS labeled_1\r\n}\r\nRETURN COALESCE(labeled_4, 0) + COALESCE(labeled_3, 0) +\r\n       COALESCE(labeled_2, 0) + COALESCE(labeled_1, 0)\r\n       AS patterns_labeled;\r\n"
        },
        "params": {}
      },
      "style": {
        "code": {
          "value": "// A palette of colors used to color distinct node labels\nDefine(COLOR_PALETTE, AsArray(\n  #DD2222, #FB6E00, #FFC500, #720096,\n  #5E4FA2, #3288BD, #66C2A5, #ABDDA4,\n  #E6F598, #FEE08B, #D53E4F, #9E0142\n))\nDefine(COLOR_PALETTE_ITER, AsIterator(COLOR_PALETTE))\n\n// If there are no palette colors to use, use random colors instead\nDefine(RandomColor, Function(RGB(RandomInt(255), RandomInt(255), RandomInt(255))))\nDefine(GetNextColor, Function(\n  Coalesce(Next(COLOR_PALETTE_ITER), RandomColor())\n))\n\n// Cache map to keep a selected color for each node label\nDefine(ColorByLabel, AsMap())\nDefine(GetColorByLabel, Function(labels, Coalesce(\n  Get(ColorByLabel, labels),\n  Set(ColorByLabel, labels, GetNextColor())\n)))\nDefine(JoinLabels, Function(labels, Join(Sort(labels), \":\")))\n\n// Baseline node style that will be applied to every single node\n@NodeStyle {\n  Define(COLOR, GetColorByLabel(JoinLabels(Labels(node))))\n\n  size: 6\n  color: COLOR\n  color-hover: Lighter(COLOR)\n  color-selected: Darker(COLOR)\n  border-width: 0.6\n  border-color: #1D1D1D\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Overwrite node text with the node label if defined\n@NodeStyle Greater(Size(Labels(node)), 0) {\n  label: Format(\":{}\", Join(Labels(node), \" :\"))\n}\n\n// Overwrite node text with the property \"name\" if defined\n@NodeStyle HasProperty(node, \"name\") {\n  label: AsText(Property(node, \"name\"))\n}\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node label\n// @NodeStyle HasLabel(node, \"MyCustomLabel\") {\n//   color: black\n// }\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node property\n// @NodeStyle HasProperty(node, \"my_property_name\") {\n//   color: black\n//   label: AsText(Property(node, \"my_property_name\"))\n// }\n\nDefine(LATITUDE_FIELD, \"lat\")\nDefine(LONGITUDE_FIELD, \"lng\")\n\n// In the case of numeric latitude and longitude properties, set them up for a switch to a map view\n@NodeStyle And(IsNumber(Property(node, LATITUDE_FIELD)), IsNumber(Property(node, LONGITUDE_FIELD))) {\n  latitude: Property(node, LATITUDE_FIELD)\n  longitude: Property(node, LONGITUDE_FIELD)\n}\n\n// Baseline edge style that will be applied to every single edge\n@EdgeStyle {\n  color: #999999\n  color-hover: #1D1D1D\n  color-selected: #1D1D1D\n  width: 0.3\n  width-hover: 0.9\n  width-selected: 0.9\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Show edge text only if there is a small number of edges in the view\n@EdgeStyle Less(EdgeCount(graph), 30) {\n  label: Type(edge)\n}\n\n// In case of a map view, set the default tile layer\n@ViewStyle.Map {\n  tile-layer: \"light\"\n}\n\n// Canvas background color\n@ViewStyle {\n  background-color: #FFFFFF00\n}\n"
        },
        "title": "System Style"
      }
    },
    {
      "title": "Spider labeling query red",
      "description": "",
      "query": {
        "code": {
          "value": "// Label X-wire patterns in order of decreasing length\r\nCALL {\r\n  // 4-edge paths first\r\n  MATCH path = (start)-[:Wire*4]-(end)\r\n  WHERE\r\n    ALL(edge IN relationships(path) WHERE edge.t = 1 AND edge.pattern_id IS NULL) AND\r\n    ALL(node IN nodes(path) WHERE node.t = 2 AND node.pattern_id IS NULL) AND\r\n    id(start) < id(end)\r\n  WITH DISTINCT path, start, end,\r\n       nodes(path) AS path_nodes,\r\n       relationships(path) AS path_edges\r\n  WHERE ALL(x IN path_nodes WHERE x.pattern_id IS NULL)\r\n    AND ALL(e IN path_edges WHERE e.pattern_id IS NULL)\r\n  WITH path_nodes, path_edges, randomUUID() AS pattern_id\r\n  FOREACH (edge IN path_edges | SET edge.pattern_id = pattern_id)\r\n  FOREACH (node IN path_nodes | SET node.pattern_id = pattern_id)\r\n  RETURN COUNT(DISTINCT pattern_id) AS labeled_4\r\n}\r\nCALL {\r\n  // Then 3-edge paths\r\n  MATCH path = (start)-[:Wire*3]-(end)\r\n  WHERE\r\n    ALL(edge IN relationships(path) WHERE edge.t = 1 AND edge.pattern_id IS NULL) AND\r\n    ALL(node IN nodes(path) WHERE node.t = 2 AND node.pattern_id IS NULL) AND\r\n    id(start) < id(end)\r\n  WITH DISTINCT path, start, end,\r\n       nodes(path) AS path_nodes,\r\n       relationships(path) AS path_edges\r\n  WHERE ALL(x IN path_nodes WHERE x.pattern_id IS NULL)\r\n    AND ALL(e IN path_edges WHERE e.pattern_id IS NULL)\r\n  WITH path_nodes, path_edges, randomUUID() AS pattern_id\r\n  FOREACH (edge IN path_edges | SET edge.pattern_id = pattern_id)\r\n  FOREACH (node IN path_nodes | SET node.pattern_id = pattern_id)\r\n  RETURN COUNT(DISTINCT pattern_id) AS labeled_3\r\n}\r\nCALL {\r\n  // Then 2-edge paths\r\n  MATCH path = (start)-[:Wire*2]-(end)\r\n  WHERE\r\n    ALL(edge IN relationships(path) WHERE edge.t = 1 AND edge.pattern_id IS NULL) AND\r\n    ALL(node IN nodes(path) WHERE node.t = 2 AND node.pattern_id IS NULL) AND\r\n    id(start) < id(end)\r\n  WITH DISTINCT path, start, end,\r\n       nodes(path) AS path_nodes,\r\n       relationships(path) AS path_edges\r\n  WHERE ALL(x IN path_nodes WHERE x.pattern_id IS NULL)\r\n    AND ALL(e IN path_edges WHERE e.pattern_id IS NULL)\r\n  WITH path_nodes, path_edges, randomUUID() AS pattern_id\r\n  FOREACH (edge IN path_edges | SET edge.pattern_id = pattern_id)\r\n  FOREACH (node IN path_nodes | SET node.pattern_id = pattern_id)\r\n  RETURN COUNT(DISTINCT pattern_id) AS labeled_2\r\n}\r\nCALL {\r\n  // Finally 1-edge paths\r\n  MATCH path = (start)-[:Wire*1]-(end)\r\n  WHERE\r\n    ALL(edge IN relationships(path) WHERE edge.t = 1 AND edge.pattern_id IS NULL) AND\r\n    ALL(node IN nodes(path) WHERE node.t = 2 AND node.pattern_id IS NULL) AND\r\n    id(start) < id(end)\r\n  WITH DISTINCT path, start, end,\r\n       nodes(path) AS path_nodes,\r\n       relationships(path) AS path_edges\r\n  WHERE ALL(x IN path_nodes WHERE x.pattern_id IS NULL)\r\n    AND ALL(e IN path_edges WHERE e.pattern_id IS NULL)\r\n  WITH path_nodes, path_edges, randomUUID() AS pattern_id\r\n  FOREACH (edge IN path_edges | SET edge.pattern_id = pattern_id)\r\n  FOREACH (node IN path_nodes | SET node.pattern_id = pattern_id)\r\n  RETURN COUNT(DISTINCT pattern_id) AS labeled_1\r\n}\r\nRETURN COALESCE(labeled_4, 0) + COALESCE(labeled_3, 0) +\r\n       COALESCE(labeled_2, 0) + COALESCE(labeled_1, 0)\r\n       AS patterns_labeled;\r\n"
        },
        "params": {}
      },
      "style": {
        "code": {
          "value": "// A palette of colors used to color distinct node labels\nDefine(COLOR_PALETTE, AsArray(\n  #DD2222, #FB6E00, #FFC500, #720096,\n  #5E4FA2, #3288BD, #66C2A5, #ABDDA4,\n  #E6F598, #FEE08B, #D53E4F, #9E0142\n))\nDefine(COLOR_PALETTE_ITER, AsIterator(COLOR_PALETTE))\n\n// If there are no palette colors to use, use random colors instead\nDefine(RandomColor, Function(RGB(RandomInt(255), RandomInt(255), RandomInt(255))))\nDefine(GetNextColor, Function(\n  Coalesce(Next(COLOR_PALETTE_ITER), RandomColor())\n))\n\n// Cache map to keep a selected color for each node label\nDefine(ColorByLabel, AsMap())\nDefine(GetColorByLabel, Function(labels, Coalesce(\n  Get(ColorByLabel, labels),\n  Set(ColorByLabel, labels, GetNextColor())\n)))\nDefine(JoinLabels, Function(labels, Join(Sort(labels), \":\")))\n\n// Baseline node style that will be applied to every single node\n@NodeStyle {\n  Define(COLOR, GetColorByLabel(JoinLabels(Labels(node))))\n\n  size: 6\n  color: COLOR\n  color-hover: Lighter(COLOR)\n  color-selected: Darker(COLOR)\n  border-width: 0.6\n  border-color: #1D1D1D\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Overwrite node text with the node label if defined\n@NodeStyle Greater(Size(Labels(node)), 0) {\n  label: Format(\":{}\", Join(Labels(node), \" :\"))\n}\n\n// Overwrite node text with the property \"name\" if defined\n@NodeStyle HasProperty(node, \"name\") {\n  label: AsText(Property(node, \"name\"))\n}\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node label\n// @NodeStyle HasLabel(node, \"MyCustomLabel\") {\n//   color: black\n// }\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node property\n// @NodeStyle HasProperty(node, \"my_property_name\") {\n//   color: black\n//   label: AsText(Property(node, \"my_property_name\"))\n// }\n\nDefine(LATITUDE_FIELD, \"lat\")\nDefine(LONGITUDE_FIELD, \"lng\")\n\n// In the case of numeric latitude and longitude properties, set them up for a switch to a map view\n@NodeStyle And(IsNumber(Property(node, LATITUDE_FIELD)), IsNumber(Property(node, LONGITUDE_FIELD))) {\n  latitude: Property(node, LATITUDE_FIELD)\n  longitude: Property(node, LONGITUDE_FIELD)\n}\n\n// Baseline edge style that will be applied to every single edge\n@EdgeStyle {\n  color: #999999\n  color-hover: #1D1D1D\n  color-selected: #1D1D1D\n  width: 0.3\n  width-hover: 0.9\n  width-selected: 0.9\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Show edge text only if there is a small number of edges in the view\n@EdgeStyle Less(EdgeCount(graph), 30) {\n  label: Type(edge)\n}\n\n// In case of a map view, set the default tile layer\n@ViewStyle.Map {\n  tile-layer: \"light\"\n}\n\n// Canvas background color\n@ViewStyle {\n  background-color: #FFFFFF00\n}\n"
        },
        "title": "System Style"
      }
    },
    {
      "title": "Spider labeling query green and red",
      "description": "",
      "query": {
        "code": {
          "value": "MATCH pathA = (sA:Node)-[:Wire*1..1]-(eA:Node)\r\nWHERE sA.pattern_id IS NULL AND eA.pattern_id IS NULL\r\n  AND ALL(r IN relationships(pathA) WHERE r.t = 2 AND r.pattern_id IS NULL)\r\n  AND ALL(n IN nodes(pathA) WHERE n.pattern_id IS NULL AND n.t IN [1,2])\r\n  // alternation: every edge connects different spider types\r\n  AND ALL(r IN relationships(pathA) WHERE startNode(r).t <> endNode(r).t)\r\nWITH pathA AS p, sA AS s, eA AS e, length(pathA) AS L\r\nORDER BY L DESC, id(s), id(e)\r\nLIMIT 1\r\n\r\nWITH nodes(p) AS path_nodes, relationships(p) AS path_edges, s, e, randomUUID() AS pattern_id\r\nSET s.start_node = true, e.end_node = true\r\nFOREACH (edge IN path_edges | SET edge.pattern_id = pattern_id)\r\nFOREACH (node IN path_nodes | SET node.pattern_id = pattern_id)\r\nRETURN pattern_id, size(path_edges) AS path_length"
        },
        "params": {}
      },
      "style": {
        "code": {
          "value": "// A palette of colors used to color distinct node labels\nDefine(COLOR_PALETTE, AsArray(\n  #DD2222, #FB6E00, #FFC500, #720096,\n  #5E4FA2, #3288BD, #66C2A5, #ABDDA4,\n  #E6F598, #FEE08B, #D53E4F, #9E0142\n))\nDefine(COLOR_PALETTE_ITER, AsIterator(COLOR_PALETTE))\n\n// If there are no palette colors to use, use random colors instead\nDefine(RandomColor, Function(RGB(RandomInt(255), RandomInt(255), RandomInt(255))))\nDefine(GetNextColor, Function(\n  Coalesce(Next(COLOR_PALETTE_ITER), RandomColor())\n))\n\n// Cache map to keep a selected color for each node label\nDefine(ColorByLabel, AsMap())\nDefine(GetColorByLabel, Function(labels, Coalesce(\n  Get(ColorByLabel, labels),\n  Set(ColorByLabel, labels, GetNextColor())\n)))\nDefine(JoinLabels, Function(labels, Join(Sort(labels), \":\")))\n\n// Baseline node style that will be applied to every single node\n@NodeStyle {\n  Define(COLOR, GetColorByLabel(JoinLabels(Labels(node))))\n\n  size: 6\n  color: COLOR\n  color-hover: Lighter(COLOR)\n  color-selected: Darker(COLOR)\n  border-width: 0.6\n  border-color: #1D1D1D\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Overwrite node text with the node label if defined\n@NodeStyle Greater(Size(Labels(node)), 0) {\n  label: Format(\":{}\", Join(Labels(node), \" :\"))\n}\n\n// Overwrite node text with the property \"name\" if defined\n@NodeStyle HasProperty(node, \"name\") {\n  label: AsText(Property(node, \"name\"))\n}\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node label\n// @NodeStyle HasLabel(node, \"MyCustomLabel\") {\n//   color: black\n// }\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node property\n// @NodeStyle HasProperty(node, \"my_property_name\") {\n//   color: black\n//   label: AsText(Property(node, \"my_property_name\"))\n// }\n\nDefine(LATITUDE_FIELD, \"lat\")\nDefine(LONGITUDE_FIELD, \"lng\")\n\n// In the case of numeric latitude and longitude properties, set them up for a switch to a map view\n@NodeStyle And(IsNumber(Property(node, LATITUDE_FIELD)), IsNumber(Property(node, LONGITUDE_FIELD))) {\n  latitude: Property(node, LATITUDE_FIELD)\n  longitude: Property(node, LONGITUDE_FIELD)\n}\n\n// Baseline edge style that will be applied to every single edge\n@EdgeStyle {\n  color: #999999\n  color-hover: #1D1D1D\n  color-selected: #1D1D1D\n  width: 0.3\n  width-hover: 0.9\n  width-selected: 0.9\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Show edge text only if there is a small number of edges in the view\n@EdgeStyle Less(EdgeCount(graph), 30) {\n  label: Type(edge)\n}\n\n// In case of a map view, set the default tile layer\n@ViewStyle.Map {\n  tile-layer: \"light\"\n}\n\n// Canvas background color\n@ViewStyle {\n  background-color: #FFFFFF00\n}\n"
        },
        "title": "System Style"
      }
    },
    {
      "title": "Local complement labeling",
      "description": "",
      "query": {
        "code": {
          "value": "// 1) Candidates: green spiders (t=1), phase ±0.5, unlabeled, no boundary neighbors\r\nMATCH (s)\r\nWHERE s.t = 1\r\n  AND (s.phase = 0.5 OR s.phase = -0.5)\r\n  AND s.pattern_id IS NULL\r\n//OPTIONAL MATCH (s)-[:Wire]-(b {t : 0})\r\n//WHERE b IS NULL\r\n//WITH s, collect(s.pattern_id) AS pids\r\n\r\n// 3) Ensure all neighbors are unlabeled\r\nMATCH (s)-[w:Wire]-(nbr)\r\nWITH s,\r\n     COLLECT(nbr) AS neighbors,\r\n     COLLECT(w) AS neighbors_edges\r\nWHERE ALL(neigh IN neighbors WHERE neigh.t = 1)\r\nAND ALL(w in neighbors_edges WHERE w.t = 2)\r\n\r\n// 4) Use a deterministic pattern id (same for all nodes in the pattern)\r\nWITH [s] + neighbors AS all_nodes, randomUUID() AS pattern_id\r\n\r\n// 5) Label all nodes with the same id in one pass\r\nFOREACH (n IN all_nodes | SET n.pattern_id = pattern_id)\r\n\r\nRETURN COUNT(pattern_id) AS num_processed"
        },
        "params": {}
      },
      "style": {
        "code": {
          "value": "// A palette of colors used to color distinct node labels\nDefine(COLOR_PALETTE, AsArray(\n  #DD2222, #FB6E00, #FFC500, #720096,\n  #5E4FA2, #3288BD, #66C2A5, #ABDDA4,\n  #E6F598, #FEE08B, #D53E4F, #9E0142\n))\nDefine(COLOR_PALETTE_ITER, AsIterator(COLOR_PALETTE))\n\n// If there are no palette colors to use, use random colors instead\nDefine(RandomColor, Function(RGB(RandomInt(255), RandomInt(255), RandomInt(255))))\nDefine(GetNextColor, Function(\n  Coalesce(Next(COLOR_PALETTE_ITER), RandomColor())\n))\n\n// Cache map to keep a selected color for each node label\nDefine(ColorByLabel, AsMap())\nDefine(GetColorByLabel, Function(labels, Coalesce(\n  Get(ColorByLabel, labels),\n  Set(ColorByLabel, labels, GetNextColor())\n)))\nDefine(JoinLabels, Function(labels, Join(Sort(labels), \":\")))\n\n// Baseline node style that will be applied to every single node\n@NodeStyle {\n  Define(COLOR, GetColorByLabel(JoinLabels(Labels(node))))\n\n  size: 6\n  color: COLOR\n  color-hover: Lighter(COLOR)\n  color-selected: Darker(COLOR)\n  border-width: 0.6\n  border-color: #1D1D1D\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Overwrite node text with the node label if defined\n@NodeStyle Greater(Size(Labels(node)), 0) {\n  label: Format(\":{}\", Join(Labels(node), \" :\"))\n}\n\n// Overwrite node text with the property \"name\" if defined\n@NodeStyle HasProperty(node, \"name\") {\n  label: AsText(Property(node, \"name\"))\n}\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node label\n// @NodeStyle HasLabel(node, \"MyCustomLabel\") {\n//   color: black\n// }\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node property\n// @NodeStyle HasProperty(node, \"my_property_name\") {\n//   color: black\n//   label: AsText(Property(node, \"my_property_name\"))\n// }\n\nDefine(LATITUDE_FIELD, \"lat\")\nDefine(LONGITUDE_FIELD, \"lng\")\n\n// In the case of numeric latitude and longitude properties, set them up for a switch to a map view\n@NodeStyle And(IsNumber(Property(node, LATITUDE_FIELD)), IsNumber(Property(node, LONGITUDE_FIELD))) {\n  latitude: Property(node, LATITUDE_FIELD)\n  longitude: Property(node, LONGITUDE_FIELD)\n}\n\n// Baseline edge style that will be applied to every single edge\n@EdgeStyle {\n  color: #999999\n  color-hover: #1D1D1D\n  color-selected: #1D1D1D\n  width: 0.3\n  width-hover: 0.9\n  width-selected: 0.9\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Show edge text only if there is a small number of edges in the view\n@EdgeStyle Less(EdgeCount(graph), 30) {\n  label: Type(edge)\n}\n\n// In case of a map view, set the default tile layer\n@ViewStyle.Map {\n  tile-layer: \"light\"\n}\n\n// Canvas background color\n@ViewStyle {\n  background-color: #FFFFFF00\n}\n"
        },
        "title": "System Style"
      }
    },
    {
      "title": "Bialgebra labeling",
      "description": "",
      "query": {
        "code": {
          "value": "// Find inclusion-wise maximal bipartite cliques where t=1 and t=2\r\nMATCH (seed)\r\nWHERE seed.t = 1\r\nOPTIONAL MATCH (seed)-[r]-(b)\r\nWHERE b.t = 2 AND r.t = 1\r\nWITH seed, collect(DISTINCT b) AS B\r\nWHERE size(B) > 0\r\n\r\n// Find all t=1 nodes connected to ALL nodes in B\r\nMATCH (x)\r\nWHERE x.t = 1\r\nOPTIONAL MATCH (x)-[r]-(b2)\r\nWHERE b2 IN B AND r.t = 1\r\nWITH B, x, count(DISTINCT b2) AS cnt_connected\r\nWHERE cnt_connected = size(B)\r\n\r\n// Collect closure\r\nWITH B, collect(DISTINCT x) AS A\r\nWHERE size(B) + size(A) > 2\r\n\r\n// Compute degree constraint\r\nWITH A, B, A + B AS allNodes\r\nUNWIND allNodes AS n\r\n// Count all edges of type t=1\r\nOPTIONAL MATCH (n)-[r1]-(m)\r\nWHERE r1.t = 1\r\nWITH A, B, allNodes, n, count(DISTINCT m) AS total_edges\r\n\r\n// Count edges of type t=1 that connect inside the clique\r\nOPTIONAL MATCH (n)-[r2]-(m2)\r\nWHERE r2.t = 1 AND m2 IN allNodes\r\nWITH A, B, allNodes, n, total_edges, count(DISTINCT m2) AS clique_edges\r\n\r\n// Keep nodes where exactly one edge is outside the clique\r\nWITH A, B, allNodes, collect(\r\n  CASE WHEN total_edges - clique_edges = 1 THEN n ELSE NULL END\r\n) AS valid_nodes\r\nWHERE size(valid_nodes) = size(allNodes)\r\n\r\nWITH [n IN (A + B) | id(n)] AS cliqueNodeIds\r\nWITH DISTINCT cliqueNodeIds AS cliqueNodeIds         // ensure unique candidate cliques\r\n\r\n// For each clique, compute the flattened neighbor id list (excluding internal nodes)\r\nWITH collect(cliqueNodeIds) AS allCliquesIds\r\nUNWIND allCliquesIds AS cliqueIds\r\n\r\n// get every neighbor id of nodes in this clique\r\nUNWIND cliqueIds AS nid\r\nMATCH (n) WHERE id(n) = nid\r\nOPTIONAL MATCH (n)-[]-(nbr)\r\nWITH cliqueIds, collect(DISTINCT id(nbr)) AS allNbrs\r\n\r\n// remove internal ids (nodes of the clique) from neighbor list\r\nWITH cliqueIds, [x IN allNbrs WHERE NOT x IN cliqueIds] AS neighborIds\r\n\r\n// represent clique as a map of ids + neighbors\r\nWITH collect({nodes: cliqueIds, neighbors: neighborIds}) AS allCliques\r\n//RETURN allCliques\r\n// --- Phase 3: pick disjoint cliques using reduce over id-lists ---\r\nWITH allCliques\r\nWITH reduce(acc = {cliques: [], nodes: [], neigh: []}, clique IN allCliques |\r\n  CASE\r\n    WHEN\r\n      // ensure candidate clique has no node in accepted nodes (no overlap)\r\n      NONE (nid IN clique.nodes WHERE nid IN acc.nodes)\r\n      AND\r\n      // ensure no candidate node is adjacent to any accepted node\r\n      NONE (nid IN clique.nodes WHERE nid IN acc.neigh)\r\n    THEN\r\n      {\r\n        cliques: acc.cliques + [clique],\r\n        nodes: acc.nodes + clique.nodes,\r\n        neigh: acc.neigh + clique.neighbors\r\n      }\r\n    ELSE acc\r\n  END\r\n) AS accFinal\r\nWITH accFinal.cliques AS disjointCliques\r\n\r\n// --- Phase 4: assign pattern_id to chosen cliques ---\r\nUNWIND disjointCliques AS chosen\r\nWITH chosen, randomUUID() AS pid\r\nUNWIND chosen.nodes AS nid\r\nMATCH (n) WHERE id(n) = nid\r\nSET n.pattern_id = pid\r\nRETURN pid, size(chosen.nodes) AS pattern_size\r\nORDER BY pattern_size DESC;\r\n\r\n//WITH collect(A + B) AS allCliques\r\n//RETURN allCliques\r\n\r\n// Assign pattern_id if all nodes satisfy the constraint\r\n//CALL {\r\n//  WITH A, B\r\n//  WITH A + B AS allNodes, randomUUID() AS pattern_id\r\n//  UNWIND allNodes AS n\r\n//  SET n.pattern_id = pattern_id\r\n//  RETURN pattern_id\r\n//  LIMIT 1\r\n//}\r\n\r\n//RETURN A, B, size(A) + size(B) AS area, pattern_id\r\n//ORDER BY area DESC;"
        },
        "params": {}
      },
      "style": {
        "code": {
          "value": "// A palette of colors used to color distinct node labels\nDefine(COLOR_PALETTE, AsArray(\n  #DD2222, #FB6E00, #FFC500, #720096,\n  #5E4FA2, #3288BD, #66C2A5, #ABDDA4,\n  #E6F598, #FEE08B, #D53E4F, #9E0142\n))\nDefine(COLOR_PALETTE_ITER, AsIterator(COLOR_PALETTE))\n\n// If there are no palette colors to use, use random colors instead\nDefine(RandomColor, Function(RGB(RandomInt(255), RandomInt(255), RandomInt(255))))\nDefine(GetNextColor, Function(\n  Coalesce(Next(COLOR_PALETTE_ITER), RandomColor())\n))\n\n// Cache map to keep a selected color for each node label\nDefine(ColorByLabel, AsMap())\nDefine(GetColorByLabel, Function(labels, Coalesce(\n  Get(ColorByLabel, labels),\n  Set(ColorByLabel, labels, GetNextColor())\n)))\nDefine(JoinLabels, Function(labels, Join(Sort(labels), \":\")))\n\n// Baseline node style that will be applied to every single node\n@NodeStyle {\n  Define(COLOR, GetColorByLabel(JoinLabels(Labels(node))))\n\n  size: 6\n  color: COLOR\n  color-hover: Lighter(COLOR)\n  color-selected: Darker(COLOR)\n  border-width: 0.6\n  border-color: #1D1D1D\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Overwrite node text with the node label if defined\n@NodeStyle Greater(Size(Labels(node)), 0) {\n  label: Format(\":{}\", Join(Labels(node), \" :\"))\n}\n\n// Overwrite node text with the property \"name\" if defined\n@NodeStyle HasProperty(node, \"name\") {\n  label: AsText(Property(node, \"name\"))\n}\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node label\n// @NodeStyle HasLabel(node, \"MyCustomLabel\") {\n//   color: black\n// }\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node property\n// @NodeStyle HasProperty(node, \"my_property_name\") {\n//   color: black\n//   label: AsText(Property(node, \"my_property_name\"))\n// }\n\nDefine(LATITUDE_FIELD, \"lat\")\nDefine(LONGITUDE_FIELD, \"lng\")\n\n// In the case of numeric latitude and longitude properties, set them up for a switch to a map view\n@NodeStyle And(IsNumber(Property(node, LATITUDE_FIELD)), IsNumber(Property(node, LONGITUDE_FIELD))) {\n  latitude: Property(node, LATITUDE_FIELD)\n  longitude: Property(node, LONGITUDE_FIELD)\n}\n\n// Baseline edge style that will be applied to every single edge\n@EdgeStyle {\n  color: #999999\n  color-hover: #1D1D1D\n  color-selected: #1D1D1D\n  width: 0.3\n  width-hover: 0.9\n  width-selected: 0.9\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Show edge text only if there is a small number of edges in the view\n@EdgeStyle Less(EdgeCount(graph), 30) {\n  label: Type(edge)\n}\n\n// In case of a map view, set the default tile layer\n@ViewStyle.Map {\n  tile-layer: \"light\"\n}\n\n// Canvas background color\n@ViewStyle {\n  background-color: #FFFFFF00\n}\n"
        },
        "title": "System Style"
      }
    },
    {
      "title": "Spider labeling query green 2",
      "description": "",
      "query": {
        "code": {
          "value": "// --- Phase 1: Collect candidate Wire paths of length 1–4 ---\r\nMATCH path = (start)-[:Wire*1..6]-(end)\r\nWHERE id(start) < id(end)\r\n  AND ALL(e IN relationships(path) WHERE e.t = 1 AND e.pattern_id IS NULL)\r\n  AND ALL(n IN nodes(path) WHERE n.t = 1 AND n.pattern_id IS NULL)\r\nWITH DISTINCT nodes(path) AS pnodes, relationships(path) AS pedges\r\nWITH\r\n  [n IN pnodes | id(n)] AS nodeIds,\r\n  [r IN pedges | id(r)] AS edgeIds,\r\n  size(pedges) AS length\r\n\r\n//RETURN nodeIds\r\n\r\n// --- Phase 2: Precompute neighbors for each candidate pattern ---\r\nUNWIND nodeIds AS nid\r\nMATCH (n) WHERE id(n) = nid\r\nOPTIONAL MATCH (n)-[:Wire]-(nbr)\r\nWHERE NOT (id(nbr) IN nodeIds)\r\nWITH collect(DISTINCT id(nbr)) AS nbrIds, nodeIds, edgeIds, length\r\nWITH collect({\r\n  nodes: nodeIds,\r\n  edges: edgeIds,\r\n  length: length,\r\n  neighbors: nbrIds\r\n}) AS candidates\r\n//RETURN candidates\r\n\r\n// --- Phase 3: Greedy selection of disjoint and non-adjacent patterns ---\r\nUNWIND candidates AS cand\r\nWITH cand\r\nORDER BY cand.length DESC\r\nWITH collect(cand) AS sortedCandidates\r\n\r\nWITH reduce(acc = {chosen: [], nodes: [], edges: [], neigh: []}, c IN sortedCandidates |\r\n  CASE\r\n    WHEN\r\n      // ensure no node overlap\r\n      NONE(nid IN c.nodes WHERE nid IN acc.nodes)\r\n      AND\r\n      // ensure no node adjacency (no overlap with neighbor list)\r\n      NONE(nid IN c.nodes WHERE nid IN acc.neigh)\r\n    THEN {\r\n      chosen: acc.chosen + [c],\r\n      nodes: acc.nodes + c.nodes,\r\n      edges: acc.edges + c.edges,\r\n      neigh: acc.neigh + c.neighbors\r\n    }\r\n    ELSE acc\r\n  END\r\n) AS pickResult\r\n//RETURN pickResult\r\n\r\n// --- Phase 4: Assign unique pattern_id to selected disjoint patterns ---\r\nUNWIND pickResult.chosen AS chosenPattern\r\nWITH chosenPattern, randomUUID() AS pid\r\n\r\n// Label nodes\r\nUNWIND chosenPattern.nodes AS nid\r\nMATCH (n) WHERE id(n) = nid\r\nSET n.pattern_id = pid\r\n\r\n// Label edges\r\nWITH chosenPattern, pid\r\nUNWIND chosenPattern.edges AS eid\r\nMATCH ()-[r]-() WHERE id(r) = eid\r\nSET r.pattern_id = pid\r\n\r\nRETURN pid, size(chosenPattern.nodes) AS pattern_size\r\nORDER BY pattern_size DESC;"
        },
        "params": {}
      },
      "style": {
        "code": {
          "value": "// A palette of colors used to color distinct node labels\nDefine(COLOR_PALETTE, AsArray(\n  #DD2222, #FB6E00, #FFC500, #720096,\n  #5E4FA2, #3288BD, #66C2A5, #ABDDA4,\n  #E6F598, #FEE08B, #D53E4F, #9E0142\n))\nDefine(COLOR_PALETTE_ITER, AsIterator(COLOR_PALETTE))\n\n// If there are no palette colors to use, use random colors instead\nDefine(RandomColor, Function(RGB(RandomInt(255), RandomInt(255), RandomInt(255))))\nDefine(GetNextColor, Function(\n  Coalesce(Next(COLOR_PALETTE_ITER), RandomColor())\n))\n\n// Cache map to keep a selected color for each node label\nDefine(ColorByLabel, AsMap())\nDefine(GetColorByLabel, Function(labels, Coalesce(\n  Get(ColorByLabel, labels),\n  Set(ColorByLabel, labels, GetNextColor())\n)))\nDefine(JoinLabels, Function(labels, Join(Sort(labels), \":\")))\n\n// Baseline node style that will be applied to every single node\n@NodeStyle {\n  Define(COLOR, GetColorByLabel(JoinLabels(Labels(node))))\n\n  size: 6\n  color: COLOR\n  color-hover: Lighter(COLOR)\n  color-selected: Darker(COLOR)\n  border-width: 0.6\n  border-color: #1D1D1D\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Overwrite node text with the node label if defined\n@NodeStyle Greater(Size(Labels(node)), 0) {\n  label: Format(\":{}\", Join(Labels(node), \" :\"))\n}\n\n// Overwrite node text with the property \"name\" if defined\n@NodeStyle HasProperty(node, \"name\") {\n  label: AsText(Property(node, \"name\"))\n}\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node label\n// @NodeStyle HasLabel(node, \"MyCustomLabel\") {\n//   color: black\n// }\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node property\n// @NodeStyle HasProperty(node, \"my_property_name\") {\n//   color: black\n//   label: AsText(Property(node, \"my_property_name\"))\n// }\n\nDefine(LATITUDE_FIELD, \"lat\")\nDefine(LONGITUDE_FIELD, \"lng\")\n\n// In the case of numeric latitude and longitude properties, set them up for a switch to a map view\n@NodeStyle And(IsNumber(Property(node, LATITUDE_FIELD)), IsNumber(Property(node, LONGITUDE_FIELD))) {\n  latitude: Property(node, LATITUDE_FIELD)\n  longitude: Property(node, LONGITUDE_FIELD)\n}\n\n// Baseline edge style that will be applied to every single edge\n@EdgeStyle {\n  color: #999999\n  color-hover: #1D1D1D\n  color-selected: #1D1D1D\n  width: 0.3\n  width-hover: 0.9\n  width-selected: 0.9\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Show edge text only if there is a small number of edges in the view\n@EdgeStyle Less(EdgeCount(graph), 30) {\n  label: Type(edge)\n}\n\n// In case of a map view, set the default tile layer\n@ViewStyle.Map {\n  tile-layer: \"light\"\n}\n\n// Canvas background color\n@ViewStyle {\n  background-color: #FFFFFF00\n}\n"
        },
        "title": "System Style"
      }
    },
    {
      "title": "Spider labeling query",
      "description": "",
      "query": {
        "code": {
          "value": "// --- Phase 1: Collect candidate Wire paths of length 1–3 ---\r\nMATCH path = (start)-[:Wire*1..3]-(end)\r\nWHERE id(start) < id(end)\r\n  AND ALL(e IN relationships(path) WHERE e.t = 1 AND e.pattern_id IS NULL)\r\n  AND (ALL(n IN nodes(path) WHERE n.t = 1 AND n.pattern_id IS NULL) OR ALL(n IN nodes(path) WHERE n.t = 2 AND n.pattern_id IS NULL))\r\nWITH DISTINCT nodes(path) AS pnodes, relationships(path) AS pedges\r\nWITH\r\n  [n IN pnodes | id(n)] AS nodeIds,\r\n  [r IN pedges | id(r)] AS edgeIds,\r\n  size(pedges) AS length\r\n\r\n// --- Phase 2: Precompute neighbors for each candidate pattern ---\r\nUNWIND nodeIds AS nid\r\nMATCH (n) WHERE id(n) = nid\r\nOPTIONAL MATCH (n)-[:Wire]-(nbr)\r\nWHERE NOT (id(nbr) IN nodeIds)\r\nWITH collect(DISTINCT id(nbr)) AS nbrIds, nodeIds, edgeIds, length\r\nWITH collect({\r\n  nodes: nodeIds,\r\n  edges: edgeIds,\r\n  length: length,\r\n  neighbors: nbrIds\r\n}) AS candidates\r\n\r\n// --- Phase 3: Greedy selection of disjoint and non-adjacent patterns ---\r\nUNWIND candidates AS cand\r\nWITH cand\r\nORDER BY cand.length DESC\r\nWITH collect(cand) AS sortedCandidates\r\n\r\n\r\nWITH reduce(acc = {chosen: [], nodes: [], neigh: []}, c IN sortedCandidates |\r\n  CASE\r\n    WHEN\r\n      // ensure no node overlap\r\n      //NONE(nid IN c.nodes WHERE nid IN acc.nodes)\r\n      size(collections.intersection(c.nodes, acc.nodes)) = 0\r\n      AND\r\n      // ensure no node adjacency (no overlap with neighbor list)\r\n      //NONE(nid IN c.nodes WHERE nid IN acc.neigh)\r\n      size(collections.intersection(c.nodes, acc.neigh)) = 0\r\n    THEN {\r\n      chosen: acc.chosen + [c],\r\n      nodes: acc.nodes + c.nodes,\r\n      neigh: acc.neigh + c.neighbors\r\n    }\r\n    ELSE acc\r\n  END\r\n) AS pickResult\r\n\r\n// --- Phase 4: Assign unique pattern_id to selected disjoint patterns ---\r\nUNWIND pickResult.chosen AS chosenPattern\r\nWITH chosenPattern, randomUUID() AS pid\r\n\r\n// Label nodes\r\nUNWIND chosenPattern.nodes AS nid\r\nMATCH (n) WHERE id(n) = nid\r\nSET n.pattern_id = pid\r\n\r\n// Label edges\r\nWITH chosenPattern, pid\r\nUNWIND chosenPattern.edges AS eid\r\nMATCH ()-[r]-() WHERE id(r) = eid\r\nSET r.pattern_id = pid\r\n\r\nRETURN count(DISTINCT pid) AS pid_count;"
        },
        "params": {}
      },
      "style": {
        "code": {
          "value": "// A palette of colors used to color distinct node labels\nDefine(COLOR_PALETTE, AsArray(\n  #DD2222, #FB6E00, #FFC500, #720096,\n  #5E4FA2, #3288BD, #66C2A5, #ABDDA4,\n  #E6F598, #FEE08B, #D53E4F, #9E0142\n))\nDefine(COLOR_PALETTE_ITER, AsIterator(COLOR_PALETTE))\n\n// If there are no palette colors to use, use random colors instead\nDefine(RandomColor, Function(RGB(RandomInt(255), RandomInt(255), RandomInt(255))))\nDefine(GetNextColor, Function(\n  Coalesce(Next(COLOR_PALETTE_ITER), RandomColor())\n))\n\n// Cache map to keep a selected color for each node label\nDefine(ColorByLabel, AsMap())\nDefine(GetColorByLabel, Function(labels, Coalesce(\n  Get(ColorByLabel, labels),\n  Set(ColorByLabel, labels, GetNextColor())\n)))\nDefine(JoinLabels, Function(labels, Join(Sort(labels), \":\")))\n\n// Baseline node style that will be applied to every single node\n@NodeStyle {\n  Define(COLOR, GetColorByLabel(JoinLabels(Labels(node))))\n\n  size: 6\n  color: COLOR\n  color-hover: Lighter(COLOR)\n  color-selected: Darker(COLOR)\n  border-width: 0.6\n  border-color: #1D1D1D\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Overwrite node text with the node label if defined\n@NodeStyle Greater(Size(Labels(node)), 0) {\n  label: Format(\":{}\", Join(Labels(node), \" :\"))\n}\n\n// Overwrite node text with the property \"name\" if defined\n@NodeStyle HasProperty(node, \"name\") {\n  label: AsText(Property(node, \"name\"))\n}\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node label\n// @NodeStyle HasLabel(node, \"MyCustomLabel\") {\n//   color: black\n// }\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node property\n// @NodeStyle HasProperty(node, \"my_property_name\") {\n//   color: black\n//   label: AsText(Property(node, \"my_property_name\"))\n// }\n\nDefine(LATITUDE_FIELD, \"lat\")\nDefine(LONGITUDE_FIELD, \"lng\")\n\n// In the case of numeric latitude and longitude properties, set them up for a switch to a map view\n@NodeStyle And(IsNumber(Property(node, LATITUDE_FIELD)), IsNumber(Property(node, LONGITUDE_FIELD))) {\n  latitude: Property(node, LATITUDE_FIELD)\n  longitude: Property(node, LONGITUDE_FIELD)\n}\n\n// Baseline edge style that will be applied to every single edge\n@EdgeStyle {\n  color: #999999\n  color-hover: #1D1D1D\n  color-selected: #1D1D1D\n  width: 0.3\n  width-hover: 0.9\n  width-selected: 0.9\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Show edge text only if there is a small number of edges in the view\n@EdgeStyle Less(EdgeCount(graph), 30) {\n  label: Type(edge)\n}\n\n// In case of a map view, set the default tile layer\n@ViewStyle.Map {\n  tile-layer: \"light\"\n}\n\n// Canvas background color\n@ViewStyle {\n  background-color: #FFFFFF00\n}\n"
        },
        "title": "System Style"
      }
    }
  ]
}