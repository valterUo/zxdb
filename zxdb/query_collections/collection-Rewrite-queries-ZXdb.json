{
  "version": 1,
  "type": "collection",
  "title": "Rewrite queries - ZXdb",
  "items": [
    {
      "title": "Hadamard edge cancellation",
      "description": "",
      "query": {
        "code": {
          "value": "// Find all marked patterns\r\nMATCH (s)\r\nWHERE s.pattern_id IS NOT NULL\r\n\r\n// Reconstruct the full path for each pattern\r\nWITH DISTINCT s.pattern_id AS pattern_id\r\nMATCH path = (start)-[:Wire*2..6]-(end)\r\nWHERE ALL(edge IN relationships(path) WHERE edge.pattern_id = pattern_id)\r\nAND start.pattern_id IS NULL AND end.pattern_id IS NULL AND id(start) < id(end)\r\n\r\nWITH start, end, pattern_id,\r\n      [node IN nodes(path)[1..-1] WHERE node.pattern_id = pattern_id] as nodes_to_delete\r\n\r\n// Create direct connection\r\nWITH DISTINCT start, end, nodes_to_delete, pattern_id\r\nCREATE (start)-[newWire:Wire {t: 1}]->(end)\r\n\r\n// Delete the nodes with the corresponding Hadamard edges\r\nWITH nodes_to_delete, pattern_id\r\nUNWIND nodes_to_delete AS node\r\nDETACH DELETE node\r\n\r\n// Return something to ensure changes were made\r\nWITH pattern_id\r\nRETURN COUNT(DISTINCT pattern_id) as patterns_processed"
        },
        "params": {}
      },
      "style": {
        "code": {
          "value": "// A palette of colors used to color distinct node labels\nDefine(COLOR_PALETTE, AsArray(\n  #DD2222, #FB6E00, #FFC500, #720096,\n  #5E4FA2, #3288BD, #66C2A5, #ABDDA4,\n  #E6F598, #FEE08B, #D53E4F, #9E0142\n))\nDefine(COLOR_PALETTE_ITER, AsIterator(COLOR_PALETTE))\n\n// If there are no palette colors to use, use random colors instead\nDefine(RandomColor, Function(RGB(RandomInt(255), RandomInt(255), RandomInt(255))))\nDefine(GetNextColor, Function(\n  Coalesce(Next(COLOR_PALETTE_ITER), RandomColor())\n))\n\n// Cache map to keep a selected color for each node label\nDefine(ColorByLabel, AsMap())\nDefine(GetColorByLabel, Function(labels, Coalesce(\n  Get(ColorByLabel, labels),\n  Set(ColorByLabel, labels, GetNextColor())\n)))\nDefine(JoinLabels, Function(labels, Join(Sort(labels), \":\")))\n\n// Baseline node style that will be applied to every single node\n@NodeStyle {\n  Define(COLOR, GetColorByLabel(JoinLabels(Labels(node))))\n\n  size: 6\n  color: COLOR\n  color-hover: Lighter(COLOR)\n  color-selected: Darker(COLOR)\n  border-width: 0.6\n  border-color: #1D1D1D\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Overwrite node text with the node label if defined\n@NodeStyle Greater(Size(Labels(node)), 0) {\n  label: Format(\":{}\", Join(Labels(node), \" :\"))\n}\n\n// Overwrite node text with the property \"name\" if defined\n@NodeStyle HasProperty(node, \"name\") {\n  label: AsText(Property(node, \"name\"))\n}\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node label\n// @NodeStyle HasLabel(node, \"MyCustomLabel\") {\n//   color: black\n// }\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node property\n// @NodeStyle HasProperty(node, \"my_property_name\") {\n//   color: black\n//   label: AsText(Property(node, \"my_property_name\"))\n// }\n\nDefine(LATITUDE_FIELD, \"lat\")\nDefine(LONGITUDE_FIELD, \"lng\")\n\n// In the case of numeric latitude and longitude properties, set them up for a switch to a map view\n@NodeStyle And(IsNumber(Property(node, LATITUDE_FIELD)), IsNumber(Property(node, LONGITUDE_FIELD))) {\n  latitude: Property(node, LATITUDE_FIELD)\n  longitude: Property(node, LONGITUDE_FIELD)\n}\n\n// Baseline edge style that will be applied to every single edge\n@EdgeStyle {\n  color: #999999\n  color-hover: #1D1D1D\n  color-selected: #1D1D1D\n  width: 0.3\n  width-hover: 0.9\n  width-selected: 0.9\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Show edge text only if there is a small number of edges in the view\n@EdgeStyle Less(EdgeCount(graph), 30) {\n  label: Type(edge)\n}\n\n// In case of a map view, set the default tile layer\n@ViewStyle.Map {\n  tile-layer: \"light\"\n}\n\n// Canvas background color\n@ViewStyle {\n  background-color: #FFFFFF00\n}\n"
        },
        "title": "System Style"
      }
    },
    {
      "title": "Spider fusion rewrite",
      "description": "",
      "query": {
        "code": {
          "value": "PROFILE CALL {\r\n  // Find all marked patterns\r\n  MATCH ()-[s:Wire]-()\r\n  WHERE s.pattern_id IS NOT NULL\r\n\r\n  // Reconstruct the full path for each pattern\r\n  WITH DISTINCT s.pattern_id AS pattern_id\r\n  MATCH path = (start)-[:Wire*1..4]-(end)\r\n  WHERE ALL(edge IN relationships(path) WHERE edge.pattern_id = pattern_id)\r\n    AND ALL(n IN nodes(path) WHERE n.pattern_id = pattern_id)\r\n    AND id(start) < id(end)\r\n    AND start.pattern_id = pattern_id\r\n    AND end.pattern_id = pattern_id\r\n\r\n  \r\n  WITH start, end, path, pattern_id,\r\n       nodes(path) AS path_nodes,\r\n       relationships(path) AS path_edges\r\n  // Identify endpoints based on having exactly one edge with this pattern_id\r\n  MATCH (start)-[r1:Wire]-()\r\n  WHERE r1.pattern_id = pattern_id\r\n  WITH start, end, path_nodes, path_edges, pattern_id, COUNT(r1) AS start_deg\r\n  MATCH (end)-[r2:Wire]-()\r\n  WHERE r2.pattern_id = pattern_id AND start <> end\r\n  WITH start, end, path_nodes, path_edges, pattern_id, start_deg, COUNT(r2) AS end_deg\r\n  WHERE start_deg = 1 AND end_deg = 1\r\n  // Calculate sum of phases from all nodes in the path\r\n  WITH start, end, path_nodes, path_edges, pattern_id,\r\n       reduce(phase_sum = 0, node IN path_nodes | phase_sum + coalesce(node.phase, 0)) AS total_phase\r\n  //LIMIT 1\r\n  //RETURN total_phase\r\n  // Find all external edges connected to any node in the path (excluding path edges)\r\n  MATCH (external)-[ext_edge:Wire]-(path_node)\r\n  WHERE path_node IN path_nodes\r\n    AND NOT external IN path_nodes\r\n    AND NOT ext_edge IN path_edges\r\n\r\n  // Collect all data needed before any modifications\r\n  WITH start, end, path_nodes, path_edges, total_phase, pattern_id,\r\n       COLLECT(DISTINCT {\r\n         external_node: external,\r\n         edge_type: ext_edge.t,\r\n         connected_to: path_node,\r\n         edge_props: properties(ext_edge)\r\n       }) AS external_connections\r\n\r\n  // Update start node with summed phase (non-destructive operation)\r\n  SET start.phase = total_phase\r\n  //RETURN start\r\n  // Create all new external connections BEFORE deleting anything\r\n  WITH start, end, path_nodes, external_connections, total_phase, pattern_id, path_edges\r\n  UNWIND external_connections AS conn\r\n  WITH start, end, conn.external_node AS external, conn.edge_type AS edge_type, \r\n       conn.edge_props AS edge_props, conn.connected_to AS connected_to,\r\n       total_phase, pattern_id, path_nodes, path_edges\r\n\r\n  // Remove existing connections between start and external\r\n  OPTIONAL MATCH (start)-[existing_edge:Wire]-(external)\r\n  DELETE existing_edge\r\n\r\n  // Create one edge for each original (path_node)-[]-(external) connection\r\n  CREATE (start)-[new_edge:Wire]->(external)\r\n  SET new_edge = edge_props\r\n\r\n  // Apply type/t adjustment only when connection came from a node other than start\r\n  SET new_edge.t = CASE\r\n                     WHEN connected_to <> start \r\n                          AND start.t <> end.t \r\n                          AND edge_type IN [1,2]\r\n                     THEN 3 - edge_type\r\n                     ELSE edge_type\r\n                   END,\r\n      start.t = CASE\r\n                    WHEN connected_to <> start \r\n                         AND start.t <> end.t\r\n                    THEN start.t\r\n                    ELSE start.t\r\n                 END,\r\n      start.pattern_id = NULL\r\n\r\n  // Collect all the data we need for deletion after all creations are done\r\n  WITH start, path_nodes, total_phase, pattern_id, COUNT(DISTINCT external) AS connections_created\r\n\r\n  // Delete all path nodes except start\r\n  UNWIND [node IN path_nodes WHERE node <> start] AS node_to_delete\r\n  DETACH DELETE node_to_delete\r\n\r\n  // Return results\r\n  WITH DISTINCT pattern_id, total_phase, connections_created\r\n  RETURN COUNT(DISTINCT pattern_id) AS patterns_processed, \r\n         COLLECT(DISTINCT total_phase) AS summed_phases,\r\n         SUM(connections_created) AS total_connections_created\r\n}\r\nCALL {\r\n  MATCH (n)\r\n  REMOVE n.pattern_id\r\n}\r\nCALL{\r\n  MATCH ()-[r]-()\r\n  REMOVE r.pattern_id\r\n}\r\nRETURN patterns_processed;\r\n"
        },
        "params": {}
      },
      "style": {
        "code": {
          "value": "// A palette of colors used to color distinct node labels\nDefine(COLOR_PALETTE, AsArray(\n  #DD2222, #FB6E00, #FFC500, #720096,\n  #5E4FA2, #3288BD, #66C2A5, #ABDDA4,\n  #E6F598, #FEE08B, #D53E4F, #9E0142\n))\nDefine(COLOR_PALETTE_ITER, AsIterator(COLOR_PALETTE))\n\n// If there are no palette colors to use, use random colors instead\nDefine(RandomColor, Function(RGB(RandomInt(255), RandomInt(255), RandomInt(255))))\nDefine(GetNextColor, Function(\n  Coalesce(Next(COLOR_PALETTE_ITER), RandomColor())\n))\n\n// Cache map to keep a selected color for each node label\nDefine(ColorByLabel, AsMap())\nDefine(GetColorByLabel, Function(labels, Coalesce(\n  Get(ColorByLabel, labels),\n  Set(ColorByLabel, labels, GetNextColor())\n)))\nDefine(JoinLabels, Function(labels, Join(Sort(labels), \":\")))\n\n// Baseline node style that will be applied to every single node\n@NodeStyle {\n  Define(COLOR, GetColorByLabel(JoinLabels(Labels(node))))\n\n  size: 6\n  color: COLOR\n  color-hover: Lighter(COLOR)\n  color-selected: Darker(COLOR)\n  border-width: 0.6\n  border-color: #1D1D1D\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Overwrite node text with the node label if defined\n@NodeStyle Greater(Size(Labels(node)), 0) {\n  label: Format(\":{}\", Join(Labels(node), \" :\"))\n}\n\n// Overwrite node text with the property \"name\" if defined\n@NodeStyle HasProperty(node, \"name\") {\n  label: AsText(Property(node, \"name\"))\n}\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node label\n// @NodeStyle HasLabel(node, \"MyCustomLabel\") {\n//   color: black\n// }\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node property\n// @NodeStyle HasProperty(node, \"my_property_name\") {\n//   color: black\n//   label: AsText(Property(node, \"my_property_name\"))\n// }\n\nDefine(LATITUDE_FIELD, \"lat\")\nDefine(LONGITUDE_FIELD, \"lng\")\n\n// In the case of numeric latitude and longitude properties, set them up for a switch to a map view\n@NodeStyle And(IsNumber(Property(node, LATITUDE_FIELD)), IsNumber(Property(node, LONGITUDE_FIELD))) {\n  latitude: Property(node, LATITUDE_FIELD)\n  longitude: Property(node, LONGITUDE_FIELD)\n}\n\n// Baseline edge style that will be applied to every single edge\n@EdgeStyle {\n  color: #999999\n  color-hover: #1D1D1D\n  color-selected: #1D1D1D\n  width: 0.3\n  width-hover: 0.9\n  width-selected: 0.9\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Show edge text only if there is a small number of edges in the view\n@EdgeStyle Less(EdgeCount(graph), 30) {\n  label: Type(edge)\n}\n\n// In case of a map view, set the default tile layer\n@ViewStyle.Map {\n  tile-layer: \"light\"\n}\n\n// Canvas background color\n@ViewStyle {\n  background-color: #FFFFFF00\n}\n"
        },
        "title": "System Style"
      }
    },
    {
      "title": "Pivot rule - two interior Pauli spiders",
      "description": "",
      "query": {
        "code": {
          "value": "// Find pivot candidates: two t=1 nodes with integer phases connected by t=2 edge\r\nMATCH (a {t: 1})-[pivot_edge:Wire {t: 2}]-(b {t: 1})\r\nWHERE id(a) < id(b)  // Process each pair once\r\n  AND a.phase IS NOT NULL \r\n  AND b.phase IS NOT NULL\r\n  // Check if phases are integer multiples of pi (phase = k for integer k)\r\n  AND a.phase = round(a.phase) \r\n  AND b.phase = round(b.phase)\r\n\r\n// Find neighbors of a (excluding b and nodes connected to b)\r\nWITH a, b, pivot_edge\r\nOPTIONAL MATCH (a)-[edge_a:Wire {t: 2}]-(neighbor_a {t: 1})\r\nWHERE neighbor_a <> b\r\n  AND NOT EXISTS((neighbor_a)-[:Wire]-(b))  // Not connected to b\r\n\r\n// Find neighbors of b (excluding a and nodes connected to a)\r\nWITH a, b, pivot_edge, COLLECT(DISTINCT neighbor_a) as neighbors_a\r\nOPTIONAL MATCH (b)-[edge_b:Wire {t: 2}]-(neighbor_b {t: 1})\r\nWHERE neighbor_b <> a\r\n  AND NOT EXISTS((neighbor_b)-[:Wire]-(a))  // Not connected to a\r\n  AND NOT neighbor_b IN neighbors_a  // Extra safety check\r\n\r\n// Find shared neighbors (connected to both a and b)\r\nWITH a, b, pivot_edge, neighbors_a, COLLECT(DISTINCT neighbor_b) as neighbors_b\r\nOPTIONAL MATCH (a)-[edge_shared_a:Wire {t: 2}]-(shared {t: 1})-[edge_shared_b:Wire {t: 2}]-(b)\r\n\r\nWITH a, b, pivot_edge, neighbors_a, neighbors_b, COLLECT(DISTINCT shared) as shared_neighbors\r\n\r\n// Update phases: add b's phase to a's neighbors (only if they exist)\r\n//WITH a, b, pivot_edge, neighbors_a, neighbors_b, shared_neighbors\r\n//UNWIND CASE WHEN size(neighbors_a) > 0 THEN neighbors_a ELSE [null] END as neighbor_a\r\n//WITH a, b, pivot_edge, neighbors_a, neighbors_b, shared_neighbors, neighbor_a\r\n//WHERE neighbor_a IS NOT NULL\r\n//SET neighbor_a.phase = coalesce(neighbor_a.phase, 0) + b.phase\r\n\r\n// Continue with the rest of the groups\r\n//WITH a, b, pivot_edge, neighbors_a, neighbors_b, shared_neighbors\r\n\r\n// Update phases: add a's phase to b's neighbors (only if they exist)\r\n//UNWIND CASE WHEN size(neighbors_b) > 0 THEN neighbors_b ELSE [null] END as neighbor_b\r\n//WITH a, b, pivot_edge, neighbors_a, neighbors_b, shared_neighbors, neighbor_b\r\n//WHERE neighbor_b IS NOT NULL\r\n//SET neighbor_b.phase = coalesce(neighbor_b.phase, 0) + a.phase\r\n\r\n// Continue with shared neighbors\r\n//WITH a, b, pivot_edge, neighbors_a, neighbors_b, shared_neighbors\r\n\r\n// Update phases: add both a's and b's phases to shared neighbors (only if they exist)\r\n//UNWIND CASE WHEN size(shared_neighbors) > 0 THEN shared_neighbors ELSE [null] END as shared_neighbor\r\n//WITH a, b, pivot_edge, neighbors_a, neighbors_b, shared_neighbors, shared_neighbor\r\n//WHERE shared_neighbor IS NOT NULL\r\n\r\n//RETURN all_neighbors\r\n//WITH a, b, pivot_edge, neighbors_a, neighbors_b, shared_neighbors\r\nLIMIT 1\r\n\r\n// Connect neighbors_a with neighbors_b\r\nUNWIND neighbors_a as node_a\r\nUNWIND neighbors_b as node_b\r\nWITH a, b, neighbors_a, neighbors_b, shared_neighbors, node_a, node_b\r\n\r\nOPTIONAL MATCH (node_a)-[existing:Wire]-(node_b)\r\nFOREACH (_ IN CASE WHEN existing IS NOT NULL THEN [1] ELSE [] END |\r\n  DELETE existing\r\n)\r\nFOREACH (_ IN CASE WHEN existing IS NULL THEN [1] ELSE [] END |\r\n  CREATE (node_a)-[:Wire {t: 2}]->(node_b)\r\n)\r\n\r\n// Connect neighbors_a with shared_neighbors\r\nWITH a, b, neighbors_a, neighbors_b, shared_neighbors\r\nLIMIT 1\r\nUNWIND neighbors_a as node_a\r\nUNWIND shared_neighbors as shared_node\r\nWITH a, b, neighbors_a, neighbors_b, shared_neighbors, node_a, shared_node\r\n\r\nOPTIONAL MATCH (node_a)-[existing:Wire]-(shared_node)\r\nFOREACH (_ IN CASE WHEN existing IS NOT NULL THEN [1] ELSE [] END |\r\n  DELETE existing\r\n)\r\nFOREACH (_ IN CASE WHEN existing IS NULL THEN [1] ELSE [] END |\r\n  CREATE (node_a)-[:Wire {t: 2}]->(shared_node)\r\n)\r\n\r\n// Connect neighbors_b with shared_neighbors\r\nWITH a, b, neighbors_a, neighbors_b, shared_neighbors\r\nLIMIT 1\r\nUNWIND neighbors_b as node_b\r\nUNWIND shared_neighbors as shared_node\r\nWITH a, b, node_b, shared_node, neighbors_a, neighbors_b, shared_neighbors\r\n\r\nOPTIONAL MATCH (node_b)-[existing:Wire]-(shared_node)\r\nFOREACH (_ IN CASE WHEN existing IS NOT NULL THEN [1] ELSE [] END |\r\n  DELETE existing\r\n)\r\nFOREACH (_ IN CASE WHEN existing IS NULL THEN [1] ELSE [] END |\r\n  CREATE (node_b)-[:Wire {t: 2}]->(shared_node)\r\n)\r\n\r\nWITH a, b, neighbors_a, neighbors_b, shared_neighbors\r\nLIMIT 1\r\nUNWIND neighbors_a AS neighbor_a \r\nSET neighbor_a.phase = coalesce(neighbor_a.phase, 0) + a.phase\r\n\r\nWITH a, b, neighbors_b, shared_neighbors, neighbors_a\r\nLIMIT 1\r\nUNWIND neighbors_b AS neighbor_b\r\nSET neighbor_b.phase = coalesce(neighbor_b.phase, 0) + b.phase\r\n\r\nWITH a, b, shared_neighbors, neighbors_b, neighbors_a\r\nLIMIT 1\r\nUNWIND shared_neighbors AS shared_neighbor\r\nSET shared_neighbor.phase = coalesce(shared_neighbor.phase, 0) + a.phase + b.phase + 1\r\n\r\n//RETURN neighbors_a, neighbors_b, shared_neighbors\r\n\r\n// Finally, remove nodes a and b with all their edges\r\nWITH DISTINCT a, b\r\nDETACH DELETE a, b\r\n\r\nRETURN COUNT(*) as pivot_operations_performed"
        },
        "params": {}
      },
      "style": {
        "code": {
          "value": "// A palette of colors used to color distinct node labels\nDefine(COLOR_PALETTE, AsArray(\n  #DD2222, #FB6E00, #FFC500, #720096,\n  #5E4FA2, #3288BD, #66C2A5, #ABDDA4,\n  #E6F598, #FEE08B, #D53E4F, #9E0142\n))\nDefine(COLOR_PALETTE_ITER, AsIterator(COLOR_PALETTE))\n\n// If there are no palette colors to use, use random colors instead\nDefine(RandomColor, Function(RGB(RandomInt(255), RandomInt(255), RandomInt(255))))\nDefine(GetNextColor, Function(\n  Coalesce(Next(COLOR_PALETTE_ITER), RandomColor())\n))\n\n// Cache map to keep a selected color for each node label\nDefine(ColorByLabel, AsMap())\nDefine(GetColorByLabel, Function(labels, Coalesce(\n  Get(ColorByLabel, labels),\n  Set(ColorByLabel, labels, GetNextColor())\n)))\nDefine(JoinLabels, Function(labels, Join(Sort(labels), \":\")))\n\n// Baseline node style that will be applied to every single node\n@NodeStyle {\n  Define(COLOR, GetColorByLabel(JoinLabels(Labels(node))))\n\n  size: 6\n  color: COLOR\n  color-hover: Lighter(COLOR)\n  color-selected: Darker(COLOR)\n  border-width: 0.6\n  border-color: #1D1D1D\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Overwrite node text with the node label if defined\n@NodeStyle Greater(Size(Labels(node)), 0) {\n  label: Format(\":{}\", Join(Labels(node), \" :\"))\n}\n\n// Overwrite node text with the property \"name\" if defined\n@NodeStyle HasProperty(node, \"name\") {\n  label: AsText(Property(node, \"name\"))\n}\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node label\n// @NodeStyle HasLabel(node, \"MyCustomLabel\") {\n//   color: black\n// }\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node property\n// @NodeStyle HasProperty(node, \"my_property_name\") {\n//   color: black\n//   label: AsText(Property(node, \"my_property_name\"))\n// }\n\nDefine(LATITUDE_FIELD, \"lat\")\nDefine(LONGITUDE_FIELD, \"lng\")\n\n// In the case of numeric latitude and longitude properties, set them up for a switch to a map view\n@NodeStyle And(IsNumber(Property(node, LATITUDE_FIELD)), IsNumber(Property(node, LONGITUDE_FIELD))) {\n  latitude: Property(node, LATITUDE_FIELD)\n  longitude: Property(node, LONGITUDE_FIELD)\n}\n\n// Baseline edge style that will be applied to every single edge\n@EdgeStyle {\n  color: #999999\n  color-hover: #1D1D1D\n  color-selected: #1D1D1D\n  width: 0.3\n  width-hover: 0.9\n  width-selected: 0.9\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Show edge text only if there is a small number of edges in the view\n@EdgeStyle Less(EdgeCount(graph), 30) {\n  label: Type(edge)\n}\n\n// In case of a map view, set the default tile layer\n@ViewStyle.Map {\n  tile-layer: \"light\"\n}\n\n// Canvas background color\n@ViewStyle {\n  background-color: #FFFFFF00\n}\n"
        },
        "title": "System Style"
      }
    },
    {
      "title": "Pivot rule - single interior Pauli spider",
      "description": "",
      "query": {
        "code": {
          "value": "// Interior Pauli spider removal rule - Memgraph compatible\r\nMATCH (a {t: 1})-[:Wire {t : 2}]-(b {t: 1})\r\nWHERE a.phase = round(a.phase) \r\n  AND b.phase = round(b.phase)\r\n  //AND id(a) < id(b)\r\n//RETURN a.id, b.id\r\n// Check b's connectivity: exactly one boundary (t=0) and one non-boundary\r\n//WITH a, b\r\n\r\nMATCH (b)-[:Wire]-(b_neighbor)\r\nWITH a, b, \r\n     COUNT(CASE WHEN b_neighbor.t = 0 THEN 1 END) as boundary_count,\r\n     COUNT(CASE WHEN b_neighbor.t <> 0 THEN 1 END) as non_boundary_count,\r\n     COLLECT(CASE WHEN b_neighbor.t = 0 THEN b_neighbor END)[0] as boundary_vertex\r\n\r\nWHERE boundary_count = 1 AND non_boundary_count = 1\r\n//RETURN a.id, b.id, boundary_vertex.id\r\n// Check that a is connected to at least one t=1 vertex with t=2 edge\r\nWITH a, b, boundary_vertex\r\nMATCH (a)-[a_edge:Wire {t: 2}]-(a_neighbor {t: 1})\r\nWITH a, b, boundary_vertex, COUNT(a_neighbor) as t1_neighbors_via_t2\r\nWHERE t1_neighbors_via_t2 > 0\r\n\r\n// Check that ALL edges from/to a have t=2\r\nWITH a, b, boundary_vertex\r\nMATCH (a)-[all_a_edges:Wire]-()\r\nWITH a, b, boundary_vertex,\r\n     COUNT(CASE WHEN all_a_edges.t <> 2 THEN 1 END) as non_t2_edges\r\nWHERE non_t2_edges = 0\r\n\r\n// Take only the first match\r\nWITH a, b, boundary_vertex\r\nLIMIT 1\r\n\r\n// Get the boundary edge type\r\nWITH a, b, boundary_vertex\r\nMATCH (b)-[boundary_edge:Wire]-(boundary_vertex)\r\n\r\n// Find all neighbors of a (excluding b) and update their phases\r\nWITH a, b, boundary_vertex, boundary_edge\r\nOPTIONAL MATCH (a)-[:Wire]-(a_neighbor)\r\nWHERE a_neighbor <> b AND a_neighbor.graph_id = a.graph_id\r\n\r\n// Use FOREACH to update phases (handles empty collections automatically)\r\nWITH a, b, boundary_vertex, boundary_edge, COLLECT(a_neighbor) as a_neighbors\r\nFOREACH (neighbor IN a_neighbors |\r\n  SET neighbor.phase = (coalesce(neighbor.phase, 0) + b.phase) % 2\r\n)\r\n\r\n// Connect a to boundary with opposite edge type\r\nWITH a, b, boundary_vertex, boundary_edge,\r\n     CASE boundary_edge.t WHEN 1 THEN 2 ELSE 1 END as new_edge_type\r\n\r\nCREATE (a)-[new_connection:Wire]->(boundary_vertex)\r\nSET new_connection.t = new_edge_type,\r\n    new_connection.graph_id = a.graph_id\r\n\r\n// Remove b\r\nDETACH DELETE b\r\n\r\nRETURN COUNT(*) as interior_pauli_removed"
        },
        "params": {}
      },
      "style": {
        "code": {
          "value": "// A palette of colors used to color distinct node labels\nDefine(COLOR_PALETTE, AsArray(\n  #DD2222, #FB6E00, #FFC500, #720096,\n  #5E4FA2, #3288BD, #66C2A5, #ABDDA4,\n  #E6F598, #FEE08B, #D53E4F, #9E0142\n))\nDefine(COLOR_PALETTE_ITER, AsIterator(COLOR_PALETTE))\n\n// If there are no palette colors to use, use random colors instead\nDefine(RandomColor, Function(RGB(RandomInt(255), RandomInt(255), RandomInt(255))))\nDefine(GetNextColor, Function(\n  Coalesce(Next(COLOR_PALETTE_ITER), RandomColor())\n))\n\n// Cache map to keep a selected color for each node label\nDefine(ColorByLabel, AsMap())\nDefine(GetColorByLabel, Function(labels, Coalesce(\n  Get(ColorByLabel, labels),\n  Set(ColorByLabel, labels, GetNextColor())\n)))\nDefine(JoinLabels, Function(labels, Join(Sort(labels), \":\")))\n\n// Baseline node style that will be applied to every single node\n@NodeStyle {\n  Define(COLOR, GetColorByLabel(JoinLabels(Labels(node))))\n\n  size: 6\n  color: COLOR\n  color-hover: Lighter(COLOR)\n  color-selected: Darker(COLOR)\n  border-width: 0.6\n  border-color: #1D1D1D\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Overwrite node text with the node label if defined\n@NodeStyle Greater(Size(Labels(node)), 0) {\n  label: Format(\":{}\", Join(Labels(node), \" :\"))\n}\n\n// Overwrite node text with the property \"name\" if defined\n@NodeStyle HasProperty(node, \"name\") {\n  label: AsText(Property(node, \"name\"))\n}\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node label\n// @NodeStyle HasLabel(node, \"MyCustomLabel\") {\n//   color: black\n// }\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node property\n// @NodeStyle HasProperty(node, \"my_property_name\") {\n//   color: black\n//   label: AsText(Property(node, \"my_property_name\"))\n// }\n\nDefine(LATITUDE_FIELD, \"lat\")\nDefine(LONGITUDE_FIELD, \"lng\")\n\n// In the case of numeric latitude and longitude properties, set them up for a switch to a map view\n@NodeStyle And(IsNumber(Property(node, LATITUDE_FIELD)), IsNumber(Property(node, LONGITUDE_FIELD))) {\n  latitude: Property(node, LATITUDE_FIELD)\n  longitude: Property(node, LONGITUDE_FIELD)\n}\n\n// Baseline edge style that will be applied to every single edge\n@EdgeStyle {\n  color: #999999\n  color-hover: #1D1D1D\n  color-selected: #1D1D1D\n  width: 0.3\n  width-hover: 0.9\n  width-selected: 0.9\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Show edge text only if there is a small number of edges in the view\n@EdgeStyle Less(EdgeCount(graph), 30) {\n  label: Type(edge)\n}\n\n// In case of a map view, set the default tile layer\n@ViewStyle.Map {\n  tile-layer: \"light\"\n}\n\n// Canvas background color\n@ViewStyle {\n  background-color: #FFFFFF00\n}\n"
        },
        "title": "System Style"
      }
    },
    {
      "title": "Local complement rewrite",
      "description": "",
      "query": {
        "code": {
          "value": "// Complement each labeled pattern, add center phase to neighbors, then delete center\r\nMATCH (n) WHERE n.pattern_id IS NOT NULL\r\nWITH n.pattern_id AS pid, COLLECT(DISTINCT n) AS nodes\r\n\r\n// Count nodes per pattern\r\nUNWIND nodes AS tmp\r\nWITH pid, nodes, COUNT(tmp) AS total_nodes\r\n\r\n// Find center: node connected to all others in this pattern\r\nUNWIND nodes AS c\r\nMATCH (c)-[:Wire]-(cn)\r\nWHERE cn.pattern_id = pid\r\nWITH pid, nodes, total_nodes, c, COUNT(cn) AS deg_in_pattern\r\nWHERE deg_in_pattern = total_nodes - 1\r\nWITH pid, c AS center, nodes\r\n\r\n// Neighbors = pattern nodes except center\r\nMATCH (center)-[:Wire]-(nbr)\r\nWHERE nbr.pattern_id = pid\r\nWITH pid, center, COLLECT(DISTINCT nbr) AS neighbors\r\n\r\n// Enumerate neighbor pairs and toggle: create missing edges first\r\nUNWIND neighbors AS n1\r\nUNWIND neighbors AS n2\r\nWITH pid, center, neighbors, n1, n2\r\nWHERE id(n1) < id(n2)\r\nOPTIONAL MATCH (n1)-[e:Wire]-(n2)\r\n\r\n// Create missing edges (t=2) â€” this is the first update in the query\r\nFOREACH (_ IN CASE WHEN e IS NULL THEN [1] ELSE [] END |\r\n  CREATE (n1)-[:Wire {t: 2}]->(n2)\r\n)\r\n\r\n// Collect edges that existed to delete later (no UNWIND after this point)\r\nWITH pid, center, neighbors, COLLECT(e) AS edges_to_delete\r\n\r\n// Add center's phase to all neighbors\r\nFOREACH (n IN neighbors |\r\n  SET n.phase = coalesce(n.phase, 0) + coalesce(-center.phase, 0)\r\n)\r\n\r\n// Delete existing edges between neighbors to finish the complement\r\nFOREACH (ed IN edges_to_delete |\r\n  FOREACH (_ IN CASE WHEN ed IS NOT NULL THEN [1] ELSE [] END |\r\n    DELETE ed\r\n  )\r\n)\r\n\r\n// Remove the center and clear labels\r\nDETACH DELETE center\r\nFOREACH (n IN neighbors | SET n.pattern_id = NULL)\r\n\r\nWITH COUNT(DISTINCT pid) AS num_processed\r\nRETURN CASE WHEN num_processed > 0 THEN 1 ELSE 0 END AS changed"
        },
        "params": {}
      },
      "style": {
        "code": {
          "value": "// A palette of colors used to color distinct node labels\nDefine(COLOR_PALETTE, AsArray(\n  #DD2222, #FB6E00, #FFC500, #720096,\n  #5E4FA2, #3288BD, #66C2A5, #ABDDA4,\n  #E6F598, #FEE08B, #D53E4F, #9E0142\n))\nDefine(COLOR_PALETTE_ITER, AsIterator(COLOR_PALETTE))\n\n// If there are no palette colors to use, use random colors instead\nDefine(RandomColor, Function(RGB(RandomInt(255), RandomInt(255), RandomInt(255))))\nDefine(GetNextColor, Function(\n  Coalesce(Next(COLOR_PALETTE_ITER), RandomColor())\n))\n\n// Cache map to keep a selected color for each node label\nDefine(ColorByLabel, AsMap())\nDefine(GetColorByLabel, Function(labels, Coalesce(\n  Get(ColorByLabel, labels),\n  Set(ColorByLabel, labels, GetNextColor())\n)))\nDefine(JoinLabels, Function(labels, Join(Sort(labels), \":\")))\n\n// Baseline node style that will be applied to every single node\n@NodeStyle {\n  Define(COLOR, GetColorByLabel(JoinLabels(Labels(node))))\n\n  size: 6\n  color: COLOR\n  color-hover: Lighter(COLOR)\n  color-selected: Darker(COLOR)\n  border-width: 0.6\n  border-color: #1D1D1D\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Overwrite node text with the node label if defined\n@NodeStyle Greater(Size(Labels(node)), 0) {\n  label: Format(\":{}\", Join(Labels(node), \" :\"))\n}\n\n// Overwrite node text with the property \"name\" if defined\n@NodeStyle HasProperty(node, \"name\") {\n  label: AsText(Property(node, \"name\"))\n}\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node label\n// @NodeStyle HasLabel(node, \"MyCustomLabel\") {\n//   color: black\n// }\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node property\n// @NodeStyle HasProperty(node, \"my_property_name\") {\n//   color: black\n//   label: AsText(Property(node, \"my_property_name\"))\n// }\n\nDefine(LATITUDE_FIELD, \"lat\")\nDefine(LONGITUDE_FIELD, \"lng\")\n\n// In the case of numeric latitude and longitude properties, set them up for a switch to a map view\n@NodeStyle And(IsNumber(Property(node, LATITUDE_FIELD)), IsNumber(Property(node, LONGITUDE_FIELD))) {\n  latitude: Property(node, LATITUDE_FIELD)\n  longitude: Property(node, LONGITUDE_FIELD)\n}\n\n// Baseline edge style that will be applied to every single edge\n@EdgeStyle {\n  color: #999999\n  color-hover: #1D1D1D\n  color-selected: #1D1D1D\n  width: 0.3\n  width-hover: 0.9\n  width-selected: 0.9\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Show edge text only if there is a small number of edges in the view\n@EdgeStyle Less(EdgeCount(graph), 30) {\n  label: Type(edge)\n}\n\n// In case of a map view, set the default tile layer\n@ViewStyle.Map {\n  tile-layer: \"light\"\n}\n\n// Canvas background color\n@ViewStyle {\n  background-color: #FFFFFF00\n}\n"
        },
        "title": "System Style"
      }
    },
    {
      "title": "Gadget fusion red green",
      "description": "",
      "query": {
        "code": {
          "value": "// 1. Find all t=1 nodes and explicitly calculate their degree.\r\nMATCH (p:Node {t: 1})-[r:Wire]-(neighbor)\r\nWITH p, count(r) AS degree\r\n\r\n// 2. Filter for nodes that have a degree of exactly 1. These are our phase spiders.\r\nWHERE degree = 1\r\n\r\n// 3. Now that we have the correct 'p' nodes, find their single neighbor 'x', ensuring it's a t=2 node.\r\nMATCH (p)-[e:Wire {t: 1}]-(x:Node {t: 2})\r\n\r\n// 4. For each gadget, find its external neighbors (t=1 nodes, excluding the phase spider itself).\r\nWITH p, x\r\nMATCH (x)-[:Wire]-(n:Node {t: 1})\r\nWHERE n <> p\r\n\r\n// 5. Group gadgets by their identical set of external neighbors.\r\n// A sorted list of neighbor IDs serves as a unique key for the group.\r\nWITH p, x, n ORDER BY id(n)\r\nWITH p, x, COLLECT(id(n)) AS neighbor_key\r\n\r\n// 6. For each group (identified by neighbor_key), collect the phase spiders and their corresponding X-spiders.\r\nWITH neighbor_key, COLLECT(p) AS phase_spiders, COLLECT(x) AS x_spiders\r\n// We only care about groups with more than one gadget to fuse.\r\nWHERE size(phase_spiders) > 1\r\n\r\n// 7. UNWIND the list of phase spiders to access their properties.\r\nUNWIND phase_spiders AS ps\r\n\r\n// 8. Re-group by neighbor_key to calculate the sum of phases *for each group*.\r\nWITH\r\n    neighbor_key,\r\n    phase_spiders,\r\n    x_spiders,\r\n    sum(coalesce(ps.phase, 0.0)) AS total_phase\r\n\r\n// 9. Select one gadget to survive and identify the rest for deletion.\r\nWITH\r\n    total_phase,\r\n    phase_spiders[0] AS survivor_p,\r\n    x_spiders[0] AS survivor_x,\r\n    phase_spiders[1..] AS to_delete_p,\r\n    x_spiders[1..] AS to_delete_x\r\n\r\n// 10. Perform the rewrite:\r\n// a) Update the phase of the surviving phase spider.\r\nSET survivor_p.phase = total_phase\r\n\r\n// b) Delete all other gadgets in the group.\r\nFOREACH (p_del IN to_delete_p | DETACH DELETE p_del)\r\nFOREACH (x_del IN to_delete_x | DETACH DELETE x_del)\r\n\r\n// Return the number of fusion operations performed.\r\nRETURN count(*) AS fusions_performed;"
        },
        "params": {}
      },
      "style": {
        "code": {
          "value": "// A palette of colors used to color distinct node labels\nDefine(COLOR_PALETTE, AsArray(\n  #DD2222, #FB6E00, #FFC500, #720096,\n  #5E4FA2, #3288BD, #66C2A5, #ABDDA4,\n  #E6F598, #FEE08B, #D53E4F, #9E0142\n))\nDefine(COLOR_PALETTE_ITER, AsIterator(COLOR_PALETTE))\n\n// If there are no palette colors to use, use random colors instead\nDefine(RandomColor, Function(RGB(RandomInt(255), RandomInt(255), RandomInt(255))))\nDefine(GetNextColor, Function(\n  Coalesce(Next(COLOR_PALETTE_ITER), RandomColor())\n))\n\n// Cache map to keep a selected color for each node label\nDefine(ColorByLabel, AsMap())\nDefine(GetColorByLabel, Function(labels, Coalesce(\n  Get(ColorByLabel, labels),\n  Set(ColorByLabel, labels, GetNextColor())\n)))\nDefine(JoinLabels, Function(labels, Join(Sort(labels), \":\")))\n\n// Baseline node style that will be applied to every single node\n@NodeStyle {\n  Define(COLOR, GetColorByLabel(JoinLabels(Labels(node))))\n\n  size: 6\n  color: COLOR\n  color-hover: Lighter(COLOR)\n  color-selected: Darker(COLOR)\n  border-width: 0.6\n  border-color: #1D1D1D\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Overwrite node text with the node label if defined\n@NodeStyle Greater(Size(Labels(node)), 0) {\n  label: Format(\":{}\", Join(Labels(node), \" :\"))\n}\n\n// Overwrite node text with the property \"name\" if defined\n@NodeStyle HasProperty(node, \"name\") {\n  label: AsText(Property(node, \"name\"))\n}\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node label\n// @NodeStyle HasLabel(node, \"MyCustomLabel\") {\n//   color: black\n// }\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node property\n// @NodeStyle HasProperty(node, \"my_property_name\") {\n//   color: black\n//   label: AsText(Property(node, \"my_property_name\"))\n// }\n\nDefine(LATITUDE_FIELD, \"lat\")\nDefine(LONGITUDE_FIELD, \"lng\")\n\n// In the case of numeric latitude and longitude properties, set them up for a switch to a map view\n@NodeStyle And(IsNumber(Property(node, LATITUDE_FIELD)), IsNumber(Property(node, LONGITUDE_FIELD))) {\n  latitude: Property(node, LATITUDE_FIELD)\n  longitude: Property(node, LONGITUDE_FIELD)\n}\n\n// Baseline edge style that will be applied to every single edge\n@EdgeStyle {\n  color: #999999\n  color-hover: #1D1D1D\n  color-selected: #1D1D1D\n  width: 0.3\n  width-hover: 0.9\n  width-selected: 0.9\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Show edge text only if there is a small number of edges in the view\n@EdgeStyle Less(EdgeCount(graph), 30) {\n  label: Type(edge)\n}\n\n// In case of a map view, set the default tile layer\n@ViewStyle.Map {\n  tile-layer: \"light\"\n}\n\n// Canvas background color\n@ViewStyle {\n  background-color: #FFFFFF00\n}\n"
        },
        "title": "System Style"
      }
    },
    {
      "title": "Gadget fusion Hadamard",
      "description": "",
      "query": {
        "code": {
          "value": "// 1. Find all t=1 nodes and explicitly calculate their degree.\r\nMATCH (p:Node {t: 1})-[r:Wire]-(neighbor)\r\nWITH p, count(r) AS degree\r\n\r\n// 2. Filter for nodes that have a degree of exactly 1. These are our phase spiders.\r\nWHERE degree = 1\r\n\r\n// 3. Now that we have the correct 'p' nodes, find their single neighbor 'z_center',\r\n//    ensuring it's a Z-spider (t=1) and the connection is a Hadamard edge (t=2).\r\nMATCH (p)-[e:Wire {t: 2}]-(z_center:Node {t: 1})\r\n\r\n// 4. For each gadget, find its external neighbors: other Z-spiders (t=1) connected\r\n//    to the central Z-spider via Hadamard edges.\r\nWITH p, z_center\r\nMATCH (z_center)-[:Wire {t: 2}]-(n:Node {t: 1})\r\nWHERE n <> p\r\n\r\n// 5. Group gadgets by their identical set of external neighbors.\r\n// A sorted list of neighbor IDs serves as a unique key for the group.\r\nWITH p, z_center, n ORDER BY id(n)\r\nWITH p, z_center, COLLECT(id(n)) AS neighbor_key\r\n\r\n// 6. For each group (identified by neighbor_key), collect the phase spiders and their corresponding central spiders.\r\nWITH neighbor_key, COLLECT(p) AS phase_spiders, COLLECT(z_center) AS central_spiders\r\n// We only care about groups with more than one gadget to fuse.\r\nWHERE size(phase_spiders) > 1\r\n\r\n// 7. UNWIND the list of phase spiders to access their properties.\r\nUNWIND phase_spiders AS ps\r\n\r\n// 8. Re-group by neighbor_key to calculate the sum of phases *for each group*.\r\nWITH\r\n    neighbor_key,\r\n    phase_spiders,\r\n    central_spiders,\r\n    sum(coalesce(ps.phase, 0.0)) AS total_phase\r\n\r\n// 9. Select one gadget to survive and identify the rest for deletion.\r\nWITH\r\n    total_phase,\r\n    phase_spiders[0] AS survivor_p,\r\n    central_spiders[0] AS survivor_z,\r\n    phase_spiders[1..] AS to_delete_p,\r\n    central_spiders[1..] AS to_delete_z\r\n\r\n// 10. Perform the rewrite:\r\n// a) Update the phase of the surviving phase spider.\r\nSET survivor_p.phase = total_phase\r\n\r\n// b) Delete all other gadgets in the group (both the leaf and the now-redundant central spider).\r\nFOREACH (p_del IN to_delete_p | DETACH DELETE p_del)\r\nFOREACH (z_del IN to_delete_z | DETACH DELETE z_del)\r\n\r\n// Return the number of fusion operations performed.\r\nRETURN count(*) AS fusions_performed;"
        },
        "params": {}
      },
      "style": {
        "code": {
          "value": "// A palette of colors used to color distinct node labels\nDefine(COLOR_PALETTE, AsArray(\n  #DD2222, #FB6E00, #FFC500, #720096,\n  #5E4FA2, #3288BD, #66C2A5, #ABDDA4,\n  #E6F598, #FEE08B, #D53E4F, #9E0142\n))\nDefine(COLOR_PALETTE_ITER, AsIterator(COLOR_PALETTE))\n\n// If there are no palette colors to use, use random colors instead\nDefine(RandomColor, Function(RGB(RandomInt(255), RandomInt(255), RandomInt(255))))\nDefine(GetNextColor, Function(\n  Coalesce(Next(COLOR_PALETTE_ITER), RandomColor())\n))\n\n// Cache map to keep a selected color for each node label\nDefine(ColorByLabel, AsMap())\nDefine(GetColorByLabel, Function(labels, Coalesce(\n  Get(ColorByLabel, labels),\n  Set(ColorByLabel, labels, GetNextColor())\n)))\nDefine(JoinLabels, Function(labels, Join(Sort(labels), \":\")))\n\n// Baseline node style that will be applied to every single node\n@NodeStyle {\n  Define(COLOR, GetColorByLabel(JoinLabels(Labels(node))))\n\n  size: 6\n  color: COLOR\n  color-hover: Lighter(COLOR)\n  color-selected: Darker(COLOR)\n  border-width: 0.6\n  border-color: #1D1D1D\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Overwrite node text with the node label if defined\n@NodeStyle Greater(Size(Labels(node)), 0) {\n  label: Format(\":{}\", Join(Labels(node), \" :\"))\n}\n\n// Overwrite node text with the property \"name\" if defined\n@NodeStyle HasProperty(node, \"name\") {\n  label: AsText(Property(node, \"name\"))\n}\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node label\n// @NodeStyle HasLabel(node, \"MyCustomLabel\") {\n//   color: black\n// }\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node property\n// @NodeStyle HasProperty(node, \"my_property_name\") {\n//   color: black\n//   label: AsText(Property(node, \"my_property_name\"))\n// }\n\nDefine(LATITUDE_FIELD, \"lat\")\nDefine(LONGITUDE_FIELD, \"lng\")\n\n// In the case of numeric latitude and longitude properties, set them up for a switch to a map view\n@NodeStyle And(IsNumber(Property(node, LATITUDE_FIELD)), IsNumber(Property(node, LONGITUDE_FIELD))) {\n  latitude: Property(node, LATITUDE_FIELD)\n  longitude: Property(node, LONGITUDE_FIELD)\n}\n\n// Baseline edge style that will be applied to every single edge\n@EdgeStyle {\n  color: #999999\n  color-hover: #1D1D1D\n  color-selected: #1D1D1D\n  width: 0.3\n  width-hover: 0.9\n  width-selected: 0.9\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Show edge text only if there is a small number of edges in the view\n@EdgeStyle Less(EdgeCount(graph), 30) {\n  label: Type(edge)\n}\n\n// In case of a map view, set the default tile layer\n@ViewStyle.Map {\n  tile-layer: \"light\"\n}\n\n// Canvas background color\n@ViewStyle {\n  background-color: #FFFFFF00\n}\n"
        },
        "title": "System Style"
      }
    },
    {
      "title": "Pivot gadget",
      "description": "",
      "query": {
        "code": {
          "value": "// 1. Find pivot candidates: two t=1 nodes connected by a t=2 edge, where one has an integer phase.\r\nMATCH (z_j:Node {t: 1})-[pivot_edge:Wire {t: 2}]-(z_alpha:Node {t: 1})\r\n// Process each pair once, ensure phases exist, and check they are interior spiders.\r\nWHERE z_j.phase IS NOT NULL AND z_alpha.phase IS NOT NULL\r\n  // Check if z_j's phase is an integer multiple of pi.\r\n  AND z_j.phase = round(z_j.phase)\r\n  // NEW: Ensure both are interior spiders (no simple wires of type t=1).\r\n  AND NOT EXISTS((z_j)-[:Wire {t: 1}]-())\r\n  AND NOT EXISTS((z_alpha)-[:Wire {t: 1}]-())\r\n\r\n// 1b. Out of all candidates, keep only the one with the largest z_j.phase\r\nWITH z_j, z_alpha\r\nORDER BY z_j.phase DESC\r\nLIMIT 1\r\n\r\n// 2. Collect the three disjoint sets of neighbors.\r\n// N_j: Neighbors of z_j only.\r\nWITH z_j, z_alpha\r\nOPTIONAL MATCH (z_j)-[:Wire {t: 2}]-(n_j:Node {t: 1})\r\nWHERE NOT EXISTS((n_j)-[:Wire]-(z_alpha)) AND n_j <> z_alpha\r\nWITH z_j, z_alpha, COLLECT(DISTINCT n_j) AS neighbors_j\r\n\r\n// N_alpha: Neighbors of z_alpha only.\r\nOPTIONAL MATCH (z_alpha)-[:Wire {t: 2}]-(n_alpha:Node {t: 1})\r\nWHERE NOT EXISTS((n_alpha)-[:Wire]-(z_j)) AND n_alpha <> z_j\r\nWITH z_j, z_alpha, neighbors_j, COLLECT(DISTINCT n_alpha) AS neighbors_alpha\r\n\r\n// N_shared: Neighbors of both.\r\nOPTIONAL MATCH (z_j)-[:Wire {t: 2}]-(n_shared:Node {t: 1})-[:Wire {t: 2}]-(z_alpha)\r\nWHERE n_shared <> z_j AND n_shared <> z_alpha\r\nWITH z_j, z_alpha, neighbors_j, neighbors_alpha, COLLECT(DISTINCT n_shared) AS shared_neighbors\r\n\r\n// 3. Create the two new central nodes for the rewritten structure.\r\nCREATE (z_new_phaseless:Node {t: 1, phase: 1.0, graph_id: z_j.graph_id}),\r\n       (z_new_phased:Node {t: 1, phase: (CASE z_j.phase % 2 WHEN 0 THEN -1 ELSE 1 END) * z_alpha.phase, graph_id: z_j.graph_id})\r\nCREATE (z_new_phaseless)-[:Wire {t: 2}]->(z_new_phased)\r\n\r\n// 4. Connect the new central nodes to all neighbors.\r\n// Connect z_new_phaseless to N_j and shared\r\nFOREACH (n IN neighbors_j | CREATE (z_new_phaseless)-[:Wire {t: 2}]->(n))\r\nFOREACH (n IN shared_neighbors | CREATE (z_new_phaseless)-[:Wire {t: 2}]->(n))\r\n\r\n// 5. Create the 3-partite clique between the neighbor sets.\r\nFOREACH (n_j IN neighbors_j |\r\n    FOREACH (n_alpha IN neighbors_alpha |\r\n        CREATE (n_j)-[:Wire {t: 2}]->(n_alpha)\r\n    )\r\n)\r\nFOREACH (n_j IN neighbors_j |\r\n    FOREACH (n_shared IN shared_neighbors |\r\n        CREATE (n_j)-[:Wire {t: 2}]->(n_shared)\r\n    )\r\n)\r\nFOREACH (n_alpha IN neighbors_alpha |\r\n    FOREACH (n_shared IN shared_neighbors |\r\n        CREATE (n_alpha)-[:Wire {t: 2}]->(n_shared)\r\n    )\r\n)\r\n\r\n// 6. Update phases on the neighbor nodes.\r\nFOREACH (n IN neighbors_alpha |\r\n    SET n.phase = coalesce(n.phase, 0.0) + z_j.phase\r\n)\r\nFOREACH (n IN shared_neighbors |\r\n    SET n.phase = coalesce(n.phase, 0.0) + z_j.phase + 1\r\n)\r\n\r\n// 7. Finally, remove the original two central spiders.\r\nWITH z_j, z_alpha\r\nDETACH DELETE z_j, z_alpha\r\n\r\nRETURN count(*) AS pivot_operations_performed;"
        },
        "params": {}
      },
      "style": {
        "code": {
          "value": "// A palette of colors used to color distinct node labels\nDefine(COLOR_PALETTE, AsArray(\n  #DD2222, #FB6E00, #FFC500, #720096,\n  #5E4FA2, #3288BD, #66C2A5, #ABDDA4,\n  #E6F598, #FEE08B, #D53E4F, #9E0142\n))\nDefine(COLOR_PALETTE_ITER, AsIterator(COLOR_PALETTE))\n\n// If there are no palette colors to use, use random colors instead\nDefine(RandomColor, Function(RGB(RandomInt(255), RandomInt(255), RandomInt(255))))\nDefine(GetNextColor, Function(\n  Coalesce(Next(COLOR_PALETTE_ITER), RandomColor())\n))\n\n// Cache map to keep a selected color for each node label\nDefine(ColorByLabel, AsMap())\nDefine(GetColorByLabel, Function(labels, Coalesce(\n  Get(ColorByLabel, labels),\n  Set(ColorByLabel, labels, GetNextColor())\n)))\nDefine(JoinLabels, Function(labels, Join(Sort(labels), \":\")))\n\n// Baseline node style that will be applied to every single node\n@NodeStyle {\n  Define(COLOR, GetColorByLabel(JoinLabels(Labels(node))))\n\n  size: 6\n  color: COLOR\n  color-hover: Lighter(COLOR)\n  color-selected: Darker(COLOR)\n  border-width: 0.6\n  border-color: #1D1D1D\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Overwrite node text with the node label if defined\n@NodeStyle Greater(Size(Labels(node)), 0) {\n  label: Format(\":{}\", Join(Labels(node), \" :\"))\n}\n\n// Overwrite node text with the property \"name\" if defined\n@NodeStyle HasProperty(node, \"name\") {\n  label: AsText(Property(node, \"name\"))\n}\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node label\n// @NodeStyle HasLabel(node, \"MyCustomLabel\") {\n//   color: black\n// }\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node property\n// @NodeStyle HasProperty(node, \"my_property_name\") {\n//   color: black\n//   label: AsText(Property(node, \"my_property_name\"))\n// }\n\nDefine(LATITUDE_FIELD, \"lat\")\nDefine(LONGITUDE_FIELD, \"lng\")\n\n// In the case of numeric latitude and longitude properties, set them up for a switch to a map view\n@NodeStyle And(IsNumber(Property(node, LATITUDE_FIELD)), IsNumber(Property(node, LONGITUDE_FIELD))) {\n  latitude: Property(node, LATITUDE_FIELD)\n  longitude: Property(node, LONGITUDE_FIELD)\n}\n\n// Baseline edge style that will be applied to every single edge\n@EdgeStyle {\n  color: #999999\n  color-hover: #1D1D1D\n  color-selected: #1D1D1D\n  width: 0.3\n  width-hover: 0.9\n  width-selected: 0.9\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Show edge text only if there is a small number of edges in the view\n@EdgeStyle Less(EdgeCount(graph), 30) {\n  label: Type(edge)\n}\n\n// In case of a map view, set the default tile layer\n@ViewStyle.Map {\n  tile-layer: \"light\"\n}\n\n// Canvas background color\n@ViewStyle {\n  background-color: #FFFFFF00\n}\n"
        },
        "title": "System Style"
      }
    },
    {
      "title": "Pivot boundary",
      "description": "",
      "query": {
        "code": {
          "value": "// 1. Find pivot candidates: a t=1 interior spider (z_j) and a t=1 boundary-connected spider (z_alpha).\r\nMATCH (z_j:Node {t: 1})-[pivot_edge:Wire {t: 2}]-(z_alpha:Node {t: 1})\r\nMATCH (z_alpha)-[boundary_wire:Wire {t: 1}]-(boundary_node)\r\nWHERE z_j.phase IS NOT NULL AND z_alpha.phase IS NOT NULL\r\n  AND z_j.phase = round(z_j.phase)\r\n  AND NOT EXISTS((z_j)-[:Wire {t: 1}]-())\r\n\r\n// Ensure z_alpha has ONLY ONE t=1 wire (the one to the boundary).\r\nWITH z_j, z_alpha, boundary_node, boundary_wire\r\nOPTIONAL MATCH (z_alpha)-[w:Wire {t:1}]-()\r\nWITH z_j, z_alpha, boundary_node, boundary_wire, count(w) AS num_simple_wires\r\nWHERE num_simple_wires = 1\r\n\r\n// 1b. Out of all candidates, keep only the one with the largest z_j.phase\r\nWITH z_j, z_alpha, boundary_node, boundary_wire\r\nORDER BY z_j.phase DESC\r\nLIMIT 1\r\n\r\n// 2. Collect the three disjoint sets of neighbors (connected via Hadamard edges).\r\nWITH z_j, z_alpha, boundary_node, boundary_wire\r\nOPTIONAL MATCH (z_j)-[:Wire {t: 2}]-(n_j:Node {t: 1})\r\nWHERE NOT EXISTS((n_j)-[:Wire]-(z_alpha)) AND n_j <> z_alpha\r\nWITH z_j, z_alpha, boundary_node, boundary_wire, COLLECT(DISTINCT n_j) AS neighbors_j\r\n\r\nOPTIONAL MATCH (z_alpha)-[:Wire {t: 2}]-(n_alpha:Node {t: 1})\r\nWHERE NOT EXISTS((n_alpha)-[:Wire]-(z_j)) AND n_alpha <> z_j\r\nWITH z_j, z_alpha, boundary_node, boundary_wire, neighbors_j, COLLECT(DISTINCT n_alpha) AS neighbors_alpha\r\n\r\nOPTIONAL MATCH (z_j)-[:Wire {t: 2}]-(n_shared:Node {t: 1})-[:Wire {t: 2}]-(z_alpha)\r\nWHERE n_shared <> z_j AND n_shared <> z_alpha\r\nWITH z_j, z_alpha, boundary_node, boundary_wire, neighbors_j, neighbors_alpha, COLLECT(DISTINCT n_shared) AS shared_neighbors\r\n\r\n// RETURN z_j, z_alpha, boundary_node, boundary_wire, neighbors_j, neighbors_alpha, shared_neighbors\r\n// 3. Create the THREE new central spiders for the rewritten structure.\r\nCREATE (z_new_phaseless:Node {t: 1, phase: 1.0, graph_id: z_j.graph_id}),\r\n       (z_new_phased:Node {t: 1, graph_id: z_j.graph_id, phase: (CASE z_j.phase % 2 WHEN 0 THEN -1 ELSE 1 END) * z_alpha.phase}),\r\n       (z_j_replacement:Node {t: 1, phase: z_j.phase, graph_id: z_j.graph_id})\r\nCREATE (z_new_phaseless)-[:Wire {t: 2}]->(z_new_phased)\r\n\r\n// 4. Perform the boundary rewiring and connect the new spiders.\r\n// Connect the boundary to the new j*pi spider.\r\nCREATE (boundary_node)-[:Wire {t: 2}]->(z_j_replacement)\r\n\r\n// 5. Connect the new spiders to the neighbor sets.\r\n// Connect z_new_phaseless to N_alpha, and N_shared.\r\nFOREACH (n IN neighbors_j | CREATE (z_new_phaseless)-[:Wire {t: 2}]->(n))\r\nFOREACH (n IN shared_neighbors | CREATE (z_new_phaseless)-[:Wire {t: 2}]->(n))\r\n// Connect z_j_replacement to N_alpha, and N_shared.\r\nFOREACH (n IN neighbors_j | CREATE (z_j_replacement)-[:Wire {t: 2}]->(n))\r\nFOREACH (n IN shared_neighbors | CREATE (z_j_replacement)-[:Wire {t: 2}]->(n))\r\n\r\n// 6. Create the 3-partite clique between the neighbor sets.\r\nFOREACH (n_j IN neighbors_j |\r\n    FOREACH (n_alpha IN neighbors_alpha |\r\n        CREATE (n_j)-[:Wire {t: 2}]->(n_alpha)\r\n    )\r\n)\r\nFOREACH (n_j IN neighbors_j |\r\n    FOREACH (n_shared IN shared_neighbors |\r\n        CREATE (n_j)-[:Wire {t: 2}]->(n_shared)\r\n    )\r\n)\r\nFOREACH (n_alpha IN neighbors_alpha |\r\n    FOREACH (n_shared IN shared_neighbors |\r\n        CREATE (n_alpha)-[:Wire {t: 2}]->(n_shared)\r\n    )\r\n)\r\n\r\n// 6. Update phases on the neighbor nodes.\r\nFOREACH (n IN neighbors_alpha |\r\n    SET n.phase = coalesce(n.phase, 0.0) + z_j.phase\r\n)\r\nFOREACH (n IN shared_neighbors |\r\n    SET n.phase = coalesce(n.phase, 0.0) + z_j.phase + 1\r\n)\r\n\r\n// 8. Finally, remove the original two central spiders.\r\nWITH z_j, z_alpha, boundary_wire\r\nDELETE boundary_wire\r\nDETACH DELETE z_j, z_alpha\r\n\r\nRETURN count(*) AS pivot_operations_performed;"
        },
        "params": {}
      },
      "style": {
        "code": {
          "value": "// A palette of colors used to color distinct node labels\nDefine(COLOR_PALETTE, AsArray(\n  #DD2222, #FB6E00, #FFC500, #720096,\n  #5E4FA2, #3288BD, #66C2A5, #ABDDA4,\n  #E6F598, #FEE08B, #D53E4F, #9E0142\n))\nDefine(COLOR_PALETTE_ITER, AsIterator(COLOR_PALETTE))\n\n// If there are no palette colors to use, use random colors instead\nDefine(RandomColor, Function(RGB(RandomInt(255), RandomInt(255), RandomInt(255))))\nDefine(GetNextColor, Function(\n  Coalesce(Next(COLOR_PALETTE_ITER), RandomColor())\n))\n\n// Cache map to keep a selected color for each node label\nDefine(ColorByLabel, AsMap())\nDefine(GetColorByLabel, Function(labels, Coalesce(\n  Get(ColorByLabel, labels),\n  Set(ColorByLabel, labels, GetNextColor())\n)))\nDefine(JoinLabels, Function(labels, Join(Sort(labels), \":\")))\n\n// Baseline node style that will be applied to every single node\n@NodeStyle {\n  Define(COLOR, GetColorByLabel(JoinLabels(Labels(node))))\n\n  size: 6\n  color: COLOR\n  color-hover: Lighter(COLOR)\n  color-selected: Darker(COLOR)\n  border-width: 0.6\n  border-color: #1D1D1D\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Overwrite node text with the node label if defined\n@NodeStyle Greater(Size(Labels(node)), 0) {\n  label: Format(\":{}\", Join(Labels(node), \" :\"))\n}\n\n// Overwrite node text with the property \"name\" if defined\n@NodeStyle HasProperty(node, \"name\") {\n  label: AsText(Property(node, \"name\"))\n}\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node label\n// @NodeStyle HasLabel(node, \"MyCustomLabel\") {\n//   color: black\n// }\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node property\n// @NodeStyle HasProperty(node, \"my_property_name\") {\n//   color: black\n//   label: AsText(Property(node, \"my_property_name\"))\n// }\n\nDefine(LATITUDE_FIELD, \"lat\")\nDefine(LONGITUDE_FIELD, \"lng\")\n\n// In the case of numeric latitude and longitude properties, set them up for a switch to a map view\n@NodeStyle And(IsNumber(Property(node, LATITUDE_FIELD)), IsNumber(Property(node, LONGITUDE_FIELD))) {\n  latitude: Property(node, LATITUDE_FIELD)\n  longitude: Property(node, LONGITUDE_FIELD)\n}\n\n// Baseline edge style that will be applied to every single edge\n@EdgeStyle {\n  color: #999999\n  color-hover: #1D1D1D\n  color-selected: #1D1D1D\n  width: 0.3\n  width-hover: 0.9\n  width-selected: 0.9\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Show edge text only if there is a small number of edges in the view\n@EdgeStyle Less(EdgeCount(graph), 30) {\n  label: Type(edge)\n}\n\n// In case of a map view, set the default tile layer\n@ViewStyle.Map {\n  tile-layer: \"light\"\n}\n\n// Canvas background color\n@ViewStyle {\n  background-color: #FFFFFF00\n}\n"
        },
        "title": "System Style"
      }
    },
    {
      "title": "Bialgebra red-green",
      "description": "",
      "query": {
        "code": {
          "value": "// Rewriting: For each labeled pattern, perform the bialgebra rewrite\r\nMATCH (n1:Node {pattern_id})-[w:Wire {pattern_id}]->(n2:Node {pattern_id})\r\nWHERE n1.t = 1 AND n2.t = 2\r\n\r\n// Gather n1's neighbors (except n2), and the relationship types\r\nOPTIONAL MATCH (n1)-[edge1]-(nb1)\r\nWHERE id(nb1) <> id(n2)\r\nWITH n1, n2, w, collect(nb1) AS n1_neighs, collect(edge1) AS n1_edges\r\n\r\n// Gather n2's neighbors (except n1), and the relationship types\r\nOPTIONAL MATCH (n2)-[edge2]-(nb2)\r\nWHERE id(nb2) <> id(n1)\r\nWITH n1, n2, w, n1_neighs, n1_edges, collect(nb2) AS n2_neighs, collect(edge2) AS n2_edges\r\n\r\n// Prepare to multiply nodes\r\nWITH n1, n2, w, n1_neighs, n1_edges, n2_neighs, n2_edges,\r\n     range(0, size(n1_neighs)-1) AS n1_idx,\r\n     range(0, size(n2_neighs)-1) AS n2_idx\r\n\r\n// Create new nodes for n1 (t:2)\r\nUNWIND n1_idx AS i1\r\nCREATE (new_n1:Node {t:2, uuid: randomUUID(), original: id(n1)})\r\nWITH n1, n2, w, n1_neighs, n1_edges, n2_neighs, n2_edges, collect(new_n1) AS new_n1s, n2_idx\r\n\r\n// Create new nodes for n2 (t:1)\r\nUNWIND n2_idx AS i2\r\nCREATE (new_n2:Node {t:1, uuid: randomUUID(), original: id(n2)})\r\nWITH n1, n2, w, n1_neighs, n1_edges, n2_neighs, n2_edges, new_n1s, collect(new_n2) AS new_n2s\r\n\r\n// Reconnect previous edges for new_n1 nodes (index-safe)\r\nUNWIND range(0, size(new_n1s)-1) AS i\r\nWITH n1_neighs[i] AS nb, n1_edges[i] AS edge, new_n1s[i] AS new_n1, n1, n2, w, n2_neighs, n2_edges, new_n2s\r\nCREATE (new_n1)-[:Wire {t: edge.t}]->(nb)\r\nWITH n1, n2, w, n2_neighs, n2_edges, new_n2s, collect(new_n1) AS new_n1s\r\n\r\n// Reconnect previous edges for new_n2 nodes (index-safe)\r\nUNWIND range(0, size(new_n2s)-1) AS j\r\nWITH n2_neighs[j] AS nb, n2_edges[j] AS edge, new_n2s[j] AS new_n2, new_n1s, n1, n2\r\nCREATE (new_n2)-[:Wire {t: edge.t}]->(nb)\r\nWITH new_n1s, collect(new_n2) AS new_n2s, n1, n2\r\n\r\n// Create all-to-all connections between the new nodes\r\nUNWIND new_n1s AS n1x\r\nUNWIND new_n2s AS n2x\r\nCREATE (n1x)-[:Wire {t:1}]->(n2x)\r\n\r\n// Remove the original nodes and their connecting edge\r\nWITH n1, n2\r\nDETACH DELETE n1, n2"
        },
        "params": {}
      },
      "style": {
        "code": {
          "value": "// A palette of colors used to color distinct node labels\nDefine(COLOR_PALETTE, AsArray(\n  #DD2222, #FB6E00, #FFC500, #720096,\n  #5E4FA2, #3288BD, #66C2A5, #ABDDA4,\n  #E6F598, #FEE08B, #D53E4F, #9E0142\n))\nDefine(COLOR_PALETTE_ITER, AsIterator(COLOR_PALETTE))\n\n// If there are no palette colors to use, use random colors instead\nDefine(RandomColor, Function(RGB(RandomInt(255), RandomInt(255), RandomInt(255))))\nDefine(GetNextColor, Function(\n  Coalesce(Next(COLOR_PALETTE_ITER), RandomColor())\n))\n\n// Cache map to keep a selected color for each node label\nDefine(ColorByLabel, AsMap())\nDefine(GetColorByLabel, Function(labels, Coalesce(\n  Get(ColorByLabel, labels),\n  Set(ColorByLabel, labels, GetNextColor())\n)))\nDefine(JoinLabels, Function(labels, Join(Sort(labels), \":\")))\n\n// Baseline node style that will be applied to every single node\n@NodeStyle {\n  Define(COLOR, GetColorByLabel(JoinLabels(Labels(node))))\n\n  size: 6\n  color: COLOR\n  color-hover: Lighter(COLOR)\n  color-selected: Darker(COLOR)\n  border-width: 0.6\n  border-color: #1D1D1D\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Overwrite node text with the node label if defined\n@NodeStyle Greater(Size(Labels(node)), 0) {\n  label: Format(\":{}\", Join(Labels(node), \" :\"))\n}\n\n// Overwrite node text with the property \"name\" if defined\n@NodeStyle HasProperty(node, \"name\") {\n  label: AsText(Property(node, \"name\"))\n}\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node label\n// @NodeStyle HasLabel(node, \"MyCustomLabel\") {\n//   color: black\n// }\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node property\n// @NodeStyle HasProperty(node, \"my_property_name\") {\n//   color: black\n//   label: AsText(Property(node, \"my_property_name\"))\n// }\n\nDefine(LATITUDE_FIELD, \"lat\")\nDefine(LONGITUDE_FIELD, \"lng\")\n\n// In the case of numeric latitude and longitude properties, set them up for a switch to a map view\n@NodeStyle And(IsNumber(Property(node, LATITUDE_FIELD)), IsNumber(Property(node, LONGITUDE_FIELD))) {\n  latitude: Property(node, LATITUDE_FIELD)\n  longitude: Property(node, LONGITUDE_FIELD)\n}\n\n// Baseline edge style that will be applied to every single edge\n@EdgeStyle {\n  color: #999999\n  color-hover: #1D1D1D\n  color-selected: #1D1D1D\n  width: 0.3\n  width-hover: 0.9\n  width-selected: 0.9\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Show edge text only if there is a small number of edges in the view\n@EdgeStyle Less(EdgeCount(graph), 30) {\n  label: Type(edge)\n}\n\n// In case of a map view, set the default tile layer\n@ViewStyle.Map {\n  tile-layer: \"light\"\n}\n\n// Canvas background color\n@ViewStyle {\n  background-color: #FFFFFF00\n}\n"
        },
        "title": "System Style"
      }
    },
    {
      "title": "Bialgebra Hadamard",
      "description": "",
      "query": {
        "code": {
          "value": "// Rewriting: For each labeled pattern, perform the bialgebra rewrite\r\nMATCH (n1:Node {pattern_id})-[w:Wire {pattern_id}]->(n2:Node {pattern_id})\r\nWHERE n1.t = 1 AND n2.t = 1 AND w.t = 2\r\n\r\n// Gather n1's neighbors (except n2), and the relationship types\r\nOPTIONAL MATCH (n1)-[edge1]-(nb1)\r\nWHERE id(nb1) <> id(n2)\r\nWITH n1, n2, w, collect(nb1) AS n1_neighs, collect(edge1) AS n1_edges\r\n\r\n// Gather n2's neighbors (except n1), and the relationship types\r\nOPTIONAL MATCH (n2)-[edge2]-(nb2)\r\nWHERE id(nb2) <> id(n1)\r\nWITH n1, n2, w, n1_neighs, n1_edges, collect(nb2) AS n2_neighs, collect(edge2) AS n2_edges\r\n\r\n// Prepare to multiply nodes\r\nWITH n1, n2, w, n1_neighs, n1_edges, n2_neighs, n2_edges,\r\n     range(0, size(n1_neighs)-1) AS n1_idx,\r\n     range(0, size(n2_neighs)-1) AS n2_idx\r\n\r\n// Create new nodes for n1 (t:2)\r\nUNWIND n1_idx AS i1\r\nCREATE (new_n1:Node {t:2})\r\nWITH n1, n2, w, n1_neighs, n1_edges, n2_neighs, n2_edges, collect(new_n1) AS new_n1s, n2_idx\r\n\r\n// Create new nodes for n2 (t:1)\r\nUNWIND n2_idx AS i2\r\nCREATE (new_n2:Node {t:1})\r\nWITH n1, n2, w, n1_neighs, n1_edges, n2_neighs, n2_edges, new_n1s, collect(new_n2) AS new_n2s\r\n\r\n// Reconnect previous edges for new_n1 nodes (index-safe)\r\nUNWIND range(0, size(new_n1s)-1) AS i\r\nWITH n1_neighs[i] AS nb, n1_edges[i] AS edge, new_n1s[i] AS new_n1, n1, n2, w, n2_neighs, n2_edges, new_n2s\r\nCREATE (new_n1)-[:Wire {t: edge.t}]->(nb)\r\nWITH n1, n2, w, n2_neighs, n2_edges, new_n2s, collect(new_n1) AS new_n1s\r\n\r\n// Reconnect previous edges for new_n2 nodes (index-safe)\r\nUNWIND range(0, size(new_n2s)-1) AS j\r\nWITH n2_neighs[j] AS nb, n2_edges[j] AS edge, new_n2s[j] AS new_n2, new_n1s, n1, n2\r\nCREATE (new_n2)-[:Wire {t: CASE edge.t WHEN 1 THEN 2 ELSE 1}]->(nb)\r\nWITH new_n1s, collect(new_n2) AS new_n2s, n1, n2\r\n\r\n// Create all-to-all connections between the new nodes\r\nUNWIND new_n1s AS n1x\r\nUNWIND new_n2s AS n2x\r\nCREATE (n1x)-[:Wire {t:1}]->(n2x)\r\n\r\n// Remove the original nodes and their connecting edge\r\nWITH n1, n2\r\nDETACH DELETE n1, n2"
        },
        "params": {}
      },
      "style": {
        "code": {
          "value": "// A palette of colors used to color distinct node labels\nDefine(COLOR_PALETTE, AsArray(\n  #DD2222, #FB6E00, #FFC500, #720096,\n  #5E4FA2, #3288BD, #66C2A5, #ABDDA4,\n  #E6F598, #FEE08B, #D53E4F, #9E0142\n))\nDefine(COLOR_PALETTE_ITER, AsIterator(COLOR_PALETTE))\n\n// If there are no palette colors to use, use random colors instead\nDefine(RandomColor, Function(RGB(RandomInt(255), RandomInt(255), RandomInt(255))))\nDefine(GetNextColor, Function(\n  Coalesce(Next(COLOR_PALETTE_ITER), RandomColor())\n))\n\n// Cache map to keep a selected color for each node label\nDefine(ColorByLabel, AsMap())\nDefine(GetColorByLabel, Function(labels, Coalesce(\n  Get(ColorByLabel, labels),\n  Set(ColorByLabel, labels, GetNextColor())\n)))\nDefine(JoinLabels, Function(labels, Join(Sort(labels), \":\")))\n\n// Baseline node style that will be applied to every single node\n@NodeStyle {\n  Define(COLOR, GetColorByLabel(JoinLabels(Labels(node))))\n\n  size: 6\n  color: COLOR\n  color-hover: Lighter(COLOR)\n  color-selected: Darker(COLOR)\n  border-width: 0.6\n  border-color: #1D1D1D\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Overwrite node text with the node label if defined\n@NodeStyle Greater(Size(Labels(node)), 0) {\n  label: Format(\":{}\", Join(Labels(node), \" :\"))\n}\n\n// Overwrite node text with the property \"name\" if defined\n@NodeStyle HasProperty(node, \"name\") {\n  label: AsText(Property(node, \"name\"))\n}\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node label\n// @NodeStyle HasLabel(node, \"MyCustomLabel\") {\n//   color: black\n// }\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node property\n// @NodeStyle HasProperty(node, \"my_property_name\") {\n//   color: black\n//   label: AsText(Property(node, \"my_property_name\"))\n// }\n\nDefine(LATITUDE_FIELD, \"lat\")\nDefine(LONGITUDE_FIELD, \"lng\")\n\n// In the case of numeric latitude and longitude properties, set them up for a switch to a map view\n@NodeStyle And(IsNumber(Property(node, LATITUDE_FIELD)), IsNumber(Property(node, LONGITUDE_FIELD))) {\n  latitude: Property(node, LATITUDE_FIELD)\n  longitude: Property(node, LONGITUDE_FIELD)\n}\n\n// Baseline edge style that will be applied to every single edge\n@EdgeStyle {\n  color: #999999\n  color-hover: #1D1D1D\n  color-selected: #1D1D1D\n  width: 0.3\n  width-hover: 0.9\n  width-selected: 0.9\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Show edge text only if there is a small number of edges in the view\n@EdgeStyle Less(EdgeCount(graph), 30) {\n  label: Type(edge)\n}\n\n// In case of a map view, set the default tile layer\n@ViewStyle.Map {\n  tile-layer: \"light\"\n}\n\n// Canvas background color\n@ViewStyle {\n  background-color: #FFFFFF00\n}\n"
        },
        "title": "System Style"
      }
    },
    {
      "title": "Bialgebra simplification",
      "description": "",
      "query": {
        "code": {
          "value": "// For each pattern\r\nMATCH (a)\r\nWHERE a.pattern_id IS NOT NULL\r\nWITH DISTINCT a.pattern_id AS pid, a.graph_id AS graph_id\r\n\r\n// Collect nodes in A and B for this pattern\r\nMATCH (a1 {pattern_id: pid, t: 1})\r\nWITH pid, collect(a1) AS A, graph_id\r\nMATCH (b1 {pattern_id: pid, t: 2})\r\nWITH pid, A, collect(b1) AS B, graph_id\r\n\r\n// Create new supernodes\r\nCREATE (newA:Node {t: 2, pattern_id: pid, graph_id: graph_id})\r\nCREATE (newB:Node {t: 1, pattern_id: pid, graph_id: graph_id})\r\n\r\n// Reconnect edges to the new nodes\r\nWITH A, B, pid, newA, newB\r\nUNWIND A AS oldA\r\nMATCH (oldA)-[r]-(other)\r\nWHERE other.pattern_id IS NULL\r\nCREATE (newA)-[r2:Wire]->(other)\r\nSET r2 += properties(r)\r\nWITH pid, B, newA, newB, collect(oldA) AS oldANodes\r\n\r\nUNWIND B AS oldB\r\nMATCH (oldB)-[r]-(other)\r\nWHERE other.pattern_id IS NULL\r\nCREATE (newB)-[r2:Wire]->(other)\r\nSET r2 += properties(r)\r\nWITH pid, newA, newB, oldANodes, collect(oldB) AS oldBNodes\r\n\r\n// Connect the new supernodes\r\nCREATE (newA)-[:Wire {t: 1, graph_id: newA.graph_id}]->(newB)\r\n\r\n// Delete the old nodes\r\nFOREACH (n IN oldANodes + oldBNodes | DETACH DELETE n)\r\n\r\nRETURN pid, newA, newB;\r\n"
        },
        "params": {}
      },
      "style": {
        "code": {
          "value": "// A palette of colors used to color distinct node labels\nDefine(COLOR_PALETTE, AsArray(\n  #DD2222, #FB6E00, #FFC500, #720096,\n  #5E4FA2, #3288BD, #66C2A5, #ABDDA4,\n  #E6F598, #FEE08B, #D53E4F, #9E0142\n))\nDefine(COLOR_PALETTE_ITER, AsIterator(COLOR_PALETTE))\n\n// If there are no palette colors to use, use random colors instead\nDefine(RandomColor, Function(RGB(RandomInt(255), RandomInt(255), RandomInt(255))))\nDefine(GetNextColor, Function(\n  Coalesce(Next(COLOR_PALETTE_ITER), RandomColor())\n))\n\n// Cache map to keep a selected color for each node label\nDefine(ColorByLabel, AsMap())\nDefine(GetColorByLabel, Function(labels, Coalesce(\n  Get(ColorByLabel, labels),\n  Set(ColorByLabel, labels, GetNextColor())\n)))\nDefine(JoinLabels, Function(labels, Join(Sort(labels), \":\")))\n\n// Baseline node style that will be applied to every single node\n@NodeStyle {\n  Define(COLOR, GetColorByLabel(JoinLabels(Labels(node))))\n\n  size: 6\n  color: COLOR\n  color-hover: Lighter(COLOR)\n  color-selected: Darker(COLOR)\n  border-width: 0.6\n  border-color: #1D1D1D\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Overwrite node text with the node label if defined\n@NodeStyle Greater(Size(Labels(node)), 0) {\n  label: Format(\":{}\", Join(Labels(node), \" :\"))\n}\n\n// Overwrite node text with the property \"name\" if defined\n@NodeStyle HasProperty(node, \"name\") {\n  label: AsText(Property(node, \"name\"))\n}\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node label\n// @NodeStyle HasLabel(node, \"MyCustomLabel\") {\n//   color: black\n// }\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node property\n// @NodeStyle HasProperty(node, \"my_property_name\") {\n//   color: black\n//   label: AsText(Property(node, \"my_property_name\"))\n// }\n\nDefine(LATITUDE_FIELD, \"lat\")\nDefine(LONGITUDE_FIELD, \"lng\")\n\n// In the case of numeric latitude and longitude properties, set them up for a switch to a map view\n@NodeStyle And(IsNumber(Property(node, LATITUDE_FIELD)), IsNumber(Property(node, LONGITUDE_FIELD))) {\n  latitude: Property(node, LATITUDE_FIELD)\n  longitude: Property(node, LONGITUDE_FIELD)\n}\n\n// Baseline edge style that will be applied to every single edge\n@EdgeStyle {\n  color: #999999\n  color-hover: #1D1D1D\n  color-selected: #1D1D1D\n  width: 0.3\n  width-hover: 0.9\n  width-selected: 0.9\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Show edge text only if there is a small number of edges in the view\n@EdgeStyle Less(EdgeCount(graph), 30) {\n  label: Type(edge)\n}\n\n// In case of a map view, set the default tile layer\n@ViewStyle.Map {\n  tile-layer: \"light\"\n}\n\n// Canvas background color\n@ViewStyle {\n  background-color: #FFFFFF00\n}\n"
        },
        "title": "System Style"
      }
    }
  ]
}