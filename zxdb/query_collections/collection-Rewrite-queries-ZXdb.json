{
  "version": 1,
  "type": "collection",
  "title": "Rewrite queries - ZXdb",
  "items": [
    {
      "title": "Hadamard edge cancellation",
      "description": "",
      "query": {
        "code": {
          "value": "// Find all marked patterns\r\nMATCH (s)\r\nWHERE s.pattern_id IS NOT NULL\r\n\r\n// Reconstruct the full path for each pattern\r\nWITH DISTINCT s.pattern_id AS pattern_id\r\nMATCH path = (start)-[:Wire*2..6]-(end)\r\nWHERE ALL(edge IN relationships(path) WHERE edge.pattern_id = pattern_id)\r\nAND start.pattern_id IS NULL AND end.pattern_id IS NULL AND id(start) < id(end)\r\n\r\nWITH start, end, pattern_id,\r\n      [node IN nodes(path)[1..-1] WHERE node.pattern_id = pattern_id] as nodes_to_delete\r\n\r\n// Create direct connection\r\nWITH DISTINCT start, end, nodes_to_delete, pattern_id\r\nCREATE (start)-[newWire:Wire {t: 1}]->(end)\r\n\r\n// Delete the nodes with the corresponding Hadamard edges\r\nWITH nodes_to_delete, pattern_id\r\nUNWIND nodes_to_delete AS node\r\nDETACH DELETE node\r\n\r\n// Return something to ensure changes were made\r\nWITH pattern_id\r\nRETURN COUNT(DISTINCT pattern_id) as patterns_processed"
        },
        "params": {}
      },
      "style": {
        "code": {
          "value": "// A palette of colors used to color distinct node labels\nDefine(COLOR_PALETTE, AsArray(\n  #DD2222, #FB6E00, #FFC500, #720096,\n  #5E4FA2, #3288BD, #66C2A5, #ABDDA4,\n  #E6F598, #FEE08B, #D53E4F, #9E0142\n))\nDefine(COLOR_PALETTE_ITER, AsIterator(COLOR_PALETTE))\n\n// If there are no palette colors to use, use random colors instead\nDefine(RandomColor, Function(RGB(RandomInt(255), RandomInt(255), RandomInt(255))))\nDefine(GetNextColor, Function(\n  Coalesce(Next(COLOR_PALETTE_ITER), RandomColor())\n))\n\n// Cache map to keep a selected color for each node label\nDefine(ColorByLabel, AsMap())\nDefine(GetColorByLabel, Function(labels, Coalesce(\n  Get(ColorByLabel, labels),\n  Set(ColorByLabel, labels, GetNextColor())\n)))\nDefine(JoinLabels, Function(labels, Join(Sort(labels), \":\")))\n\n// Baseline node style that will be applied to every single node\n@NodeStyle {\n  Define(COLOR, GetColorByLabel(JoinLabels(Labels(node))))\n\n  size: 6\n  color: COLOR\n  color-hover: Lighter(COLOR)\n  color-selected: Darker(COLOR)\n  border-width: 0.6\n  border-color: #1D1D1D\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Overwrite node text with the node label if defined\n@NodeStyle Greater(Size(Labels(node)), 0) {\n  label: Format(\":{}\", Join(Labels(node), \" :\"))\n}\n\n// Overwrite node text with the property \"name\" if defined\n@NodeStyle HasProperty(node, \"name\") {\n  label: AsText(Property(node, \"name\"))\n}\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node label\n// @NodeStyle HasLabel(node, \"MyCustomLabel\") {\n//   color: black\n// }\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node property\n// @NodeStyle HasProperty(node, \"my_property_name\") {\n//   color: black\n//   label: AsText(Property(node, \"my_property_name\"))\n// }\n\nDefine(LATITUDE_FIELD, \"lat\")\nDefine(LONGITUDE_FIELD, \"lng\")\n\n// In the case of numeric latitude and longitude properties, set them up for a switch to a map view\n@NodeStyle And(IsNumber(Property(node, LATITUDE_FIELD)), IsNumber(Property(node, LONGITUDE_FIELD))) {\n  latitude: Property(node, LATITUDE_FIELD)\n  longitude: Property(node, LONGITUDE_FIELD)\n}\n\n// Baseline edge style that will be applied to every single edge\n@EdgeStyle {\n  color: #999999\n  color-hover: #1D1D1D\n  color-selected: #1D1D1D\n  width: 0.3\n  width-hover: 0.9\n  width-selected: 0.9\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Show edge text only if there is a small number of edges in the view\n@EdgeStyle Less(EdgeCount(graph), 30) {\n  label: Type(edge)\n}\n\n// In case of a map view, set the default tile layer\n@ViewStyle.Map {\n  tile-layer: \"light\"\n}\n\n// Canvas background color\n@ViewStyle {\n  background-color: #FFFFFF00\n}\n"
        },
        "title": "System Style"
      }
    },
    {
      "title": "Spider fusion rewrite",
      "description": "",
      "query": {
        "code": {
          "value": "CALL {\r\n// Find all marked patterns\r\nMATCH ()-[s:Wire]-()\r\nWHERE s.pattern_id IS NOT NULL\r\n\r\n// Reconstruct the full path for each pattern\r\nWITH DISTINCT s.pattern_id AS pattern_id\r\nMATCH path = (start)-[:Wire*0..4]-(end)\r\nWHERE ALL(edge IN relationships(path) WHERE edge.pattern_id = pattern_id)\r\n  AND id(start) < id(end)\r\n  AND start.start_node = True \r\n  AND end.end_node = True\r\n\r\nWITH start, end, path, pattern_id,\r\n     nodes(path) as path_nodes,\r\n     relationships(path) as path_edges\r\n\r\n// Calculate sum of phases from all nodes in the path\r\nWITH start, end, path_nodes, path_edges, pattern_id,\r\n     reduce(phase_sum = 0, node IN path_nodes | phase_sum + coalesce(node.phase, 0)) as total_phase\r\n\r\n// Find all external edges connected to any node in the path (excluding path edges)\r\nMATCH (external)-[ext_edge:Wire]-(path_node)\r\nWHERE path_node IN path_nodes\r\n  AND NOT external IN path_nodes\r\n  AND NOT ext_edge IN path_edges\r\n\r\n// Collect all data needed before any modifications\r\nWITH start, path_nodes, path_edges, total_phase, pattern_id,\r\n     COLLECT(DISTINCT {\r\n       external_node: external,\r\n       edge_type: ext_edge.t,\r\n       connected_to: path_node,\r\n       edge_props: properties(ext_edge)\r\n     }) as external_connections\r\n\r\n// Update start node with summed phase (non-destructive operation)\r\nSET start.phase = total_phase % 2\r\n\r\n// Create all new external connections BEFORE deleting anything\r\nWITH start, path_nodes, external_connections, total_phase, pattern_id, path_edges\r\nUNWIND external_connections AS conn\r\nWITH start, conn.external_node as external, conn.edge_type as edge_type, \r\n     conn.edge_props as edge_props, total_phase, pattern_id, path_nodes, path_edges\r\n\r\n// Remove existing connections between start and external\r\nOPTIONAL MATCH (start)-[existing_edge:Wire]-(external)\r\nDELETE existing_edge\r\n\r\n// Create one edge for each original (path_node)-[]-(external) connection\r\nCREATE (start)-[new_edge:Wire]->(external)\r\nSET new_edge = edge_props, \r\n    new_edge.t = edge_type,\r\n    new_edge.connection_count = pattern_id\r\n\r\n// Collect all the data we need for deletion after all creations are done\r\nWITH start, path_nodes, total_phase, pattern_id, path_edges,\r\n     COUNT(DISTINCT external) as connections_created\r\n\r\n// Delete all path nodes except start\r\nWITH start, path_nodes, total_phase, pattern_id, connections_created\r\nUNWIND [node IN path_nodes WHERE node <> start] AS node_to_delete\r\nDETACH DELETE node_to_delete\r\n\r\n// Return results\r\nWITH DISTINCT pattern_id, total_phase, connections_created\r\nRETURN COUNT(DISTINCT pattern_id) as patterns_processed, \r\n       COLLECT(DISTINCT total_phase) as summed_phases,\r\n       SUM(connections_created) as total_connections_created\r\n}\r\n\r\nRETURN patterns_processed"
        },
        "params": {}
      },
      "style": {
        "code": {
          "value": "// A palette of colors used to color distinct node labels\nDefine(COLOR_PALETTE, AsArray(\n  #DD2222, #FB6E00, #FFC500, #720096,\n  #5E4FA2, #3288BD, #66C2A5, #ABDDA4,\n  #E6F598, #FEE08B, #D53E4F, #9E0142\n))\nDefine(COLOR_PALETTE_ITER, AsIterator(COLOR_PALETTE))\n\n// If there are no palette colors to use, use random colors instead\nDefine(RandomColor, Function(RGB(RandomInt(255), RandomInt(255), RandomInt(255))))\nDefine(GetNextColor, Function(\n  Coalesce(Next(COLOR_PALETTE_ITER), RandomColor())\n))\n\n// Cache map to keep a selected color for each node label\nDefine(ColorByLabel, AsMap())\nDefine(GetColorByLabel, Function(labels, Coalesce(\n  Get(ColorByLabel, labels),\n  Set(ColorByLabel, labels, GetNextColor())\n)))\nDefine(JoinLabels, Function(labels, Join(Sort(labels), \":\")))\n\n// Baseline node style that will be applied to every single node\n@NodeStyle {\n  Define(COLOR, GetColorByLabel(JoinLabels(Labels(node))))\n\n  size: 6\n  color: COLOR\n  color-hover: Lighter(COLOR)\n  color-selected: Darker(COLOR)\n  border-width: 0.6\n  border-color: #1D1D1D\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Overwrite node text with the node label if defined\n@NodeStyle Greater(Size(Labels(node)), 0) {\n  label: Format(\":{}\", Join(Labels(node), \" :\"))\n}\n\n// Overwrite node text with the property \"name\" if defined\n@NodeStyle HasProperty(node, \"name\") {\n  label: AsText(Property(node, \"name\"))\n}\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node label\n// @NodeStyle HasLabel(node, \"MyCustomLabel\") {\n//   color: black\n// }\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node property\n// @NodeStyle HasProperty(node, \"my_property_name\") {\n//   color: black\n//   label: AsText(Property(node, \"my_property_name\"))\n// }\n\nDefine(LATITUDE_FIELD, \"lat\")\nDefine(LONGITUDE_FIELD, \"lng\")\n\n// In the case of numeric latitude and longitude properties, set them up for a switch to a map view\n@NodeStyle And(IsNumber(Property(node, LATITUDE_FIELD)), IsNumber(Property(node, LONGITUDE_FIELD))) {\n  latitude: Property(node, LATITUDE_FIELD)\n  longitude: Property(node, LONGITUDE_FIELD)\n}\n\n// Baseline edge style that will be applied to every single edge\n@EdgeStyle {\n  color: #999999\n  color-hover: #1D1D1D\n  color-selected: #1D1D1D\n  width: 0.3\n  width-hover: 0.9\n  width-selected: 0.9\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Show edge text only if there is a small number of edges in the view\n@EdgeStyle Less(EdgeCount(graph), 30) {\n  label: Type(edge)\n}\n\n// In case of a map view, set the default tile layer\n@ViewStyle.Map {\n  tile-layer: \"light\"\n}\n\n// Canvas background color\n@ViewStyle {\n  background-color: #FFFFFF00\n}\n"
        },
        "title": "System Style"
      }
    },
    {
      "title": "Pivot rule - two interior Pauli spiders",
      "description": "",
      "query": {
        "code": {
          "value": "// Find pivot candidates: two t=1 nodes with integer phases connected by t=2 edge\r\nMATCH (a {t: 1})-[pivot_edge:Wire {t: 2}]-(b {t: 1})\r\nWHERE id(a) < id(b)  // Process each pair once\r\n  AND a.phase IS NOT NULL \r\n  AND b.phase IS NOT NULL\r\n  // Check if phases are integer multiples of pi (phase = k for integer k)\r\n  AND a.phase = round(a.phase) \r\n  AND b.phase = round(b.phase)\r\n\r\n// Find neighbors of a (excluding b and nodes connected to b)\r\nWITH a, b, pivot_edge\r\nOPTIONAL MATCH (a)-[edge_a:Wire {t: 2}]-(neighbor_a {t: 1})\r\nWHERE neighbor_a <> b\r\n  AND NOT EXISTS((neighbor_a)-[:Wire]-(b))  // Not connected to b\r\n\r\n// Find neighbors of b (excluding a and nodes connected to a)\r\nWITH a, b, pivot_edge, COLLECT(DISTINCT neighbor_a) as neighbors_a\r\nOPTIONAL MATCH (b)-[edge_b:Wire {t: 2}]-(neighbor_b {t: 1})\r\nWHERE neighbor_b <> a\r\n  AND NOT EXISTS((neighbor_b)-[:Wire]-(a))  // Not connected to a\r\n  AND NOT neighbor_b IN neighbors_a  // Extra safety check\r\n\r\n// Find shared neighbors (connected to both a and b)\r\nWITH a, b, pivot_edge, neighbors_a, COLLECT(DISTINCT neighbor_b) as neighbors_b\r\nOPTIONAL MATCH (a)-[edge_shared_a:Wire {t: 2}]-(shared {t: 1})-[edge_shared_b:Wire {t: 2}]-(b)\r\n\r\nWITH a, b, pivot_edge, neighbors_a, neighbors_b, COLLECT(DISTINCT shared) as shared_neighbors\r\n\r\n// Update phases: add b's phase to a's neighbors (only if they exist)\r\nWITH a, b, pivot_edge, neighbors_a, neighbors_b, shared_neighbors\r\nUNWIND CASE WHEN size(neighbors_a) > 0 THEN neighbors_a ELSE [null] END as neighbor_a\r\nWITH a, b, pivot_edge, neighbors_a, neighbors_b, shared_neighbors, neighbor_a\r\nWHERE neighbor_a IS NOT NULL\r\n//SET neighbor_a.phase = coalesce(neighbor_a.phase, 0) + b.phase\r\n\r\n// Continue with the rest of the groups\r\nWITH a, b, pivot_edge, neighbors_a, neighbors_b, shared_neighbors\r\n\r\n// Update phases: add a's phase to b's neighbors (only if they exist)\r\nUNWIND CASE WHEN size(neighbors_b) > 0 THEN neighbors_b ELSE [null] END as neighbor_b\r\nWITH a, b, pivot_edge, neighbors_a, neighbors_b, shared_neighbors, neighbor_b\r\nWHERE neighbor_b IS NOT NULL\r\n//SET neighbor_b.phase = coalesce(neighbor_b.phase, 0) + a.phase\r\n\r\n// Continue with shared neighbors\r\nWITH a, b, pivot_edge, neighbors_a, neighbors_b, shared_neighbors\r\n\r\n// Update phases: add both a's and b's phases to shared neighbors (only if they exist)\r\nUNWIND CASE WHEN size(shared_neighbors) > 0 THEN shared_neighbors ELSE [null] END as shared_neighbor\r\nWITH a, b, pivot_edge, neighbors_a, neighbors_b, shared_neighbors, shared_neighbor\r\nWHERE shared_neighbor IS NOT NULL\r\n//SET shared_neighbor.phase = coalesce(shared_neighbor.phase, 0) + a.phase + b.phase\r\n\r\n// Collect all neighbor nodes for local complement\r\n//WITH a, b, pivot_edge, neighbors_a, neighbors_b, shared_neighbors,\r\n//     neighbors_a + neighbors_b + shared_neighbors as all_neighbors\r\n\r\n// Only perform local complement if there are neighbors\r\n//WHERE size(all_neighbors) > 0\r\n\r\n//RETURN all_neighbors\r\nWITH a, b, pivot_edge, neighbors_a, neighbors_b, shared_neighbors\r\nLIMIT 1\r\n\r\n\r\n// Local complement between different groups\r\n//WITH a, b, pivot_edge, neighbors_a, neighbors_b, shared_neighbors\r\n\r\n// Connect neighbors_a with neighbors_b\r\nUNWIND neighbors_a as node_a\r\nUNWIND neighbors_b as node_b\r\nWITH a, b, neighbors_a, neighbors_b, shared_neighbors, node_a, node_b\r\n\r\nOPTIONAL MATCH (node_a)-[existing:Wire]-(node_b)\r\nFOREACH (_ IN CASE WHEN existing IS NOT NULL THEN [1] ELSE [] END |\r\n  DELETE existing\r\n)\r\nFOREACH (_ IN CASE WHEN existing IS NULL THEN [1] ELSE [] END |\r\n  CREATE (node_a)-[:Wire {t: 2, graph_id: node_a.graph_id}]->(node_b)\r\n)\r\n\r\n// Connect neighbors_a with shared_neighbors\r\nWITH a, b, neighbors_a, neighbors_b, shared_neighbors\r\nLIMIT 1\r\nUNWIND neighbors_a as node_a\r\nUNWIND shared_neighbors as shared_node\r\nWITH a, b, neighbors_a, neighbors_b, shared_neighbors, node_a, shared_node\r\n\r\nOPTIONAL MATCH (node_a)-[existing:Wire]-(shared_node)\r\nFOREACH (_ IN CASE WHEN existing IS NOT NULL THEN [1] ELSE [] END |\r\n  DELETE existing\r\n)\r\nFOREACH (_ IN CASE WHEN existing IS NULL THEN [1] ELSE [] END |\r\n  CREATE (node_a)-[:Wire {t: 2, graph_id: node_a.graph_id}]->(shared_node)\r\n)\r\n\r\n// Connect neighbors_b with shared_neighbors\r\nWITH a, b, neighbors_a, neighbors_b, shared_neighbors\r\nLIMIT 1\r\nUNWIND neighbors_b as node_b\r\nUNWIND shared_neighbors as shared_node\r\nWITH a, b, node_b, shared_node, neighbors_a, neighbors_b, shared_neighbors\r\n\r\nOPTIONAL MATCH (node_b)-[existing:Wire]-(shared_node)\r\nFOREACH (_ IN CASE WHEN existing IS NOT NULL THEN [1] ELSE [] END |\r\n  DELETE existing\r\n)\r\nFOREACH (_ IN CASE WHEN existing IS NULL THEN [1] ELSE [] END |\r\n  CREATE (node_b)-[:Wire {t: 2, graph_id: node_b.graph_id}]->(shared_node)\r\n)\r\n\r\n// Finally, remove nodes a and b with all their edges\r\nWITH a, b, neighbors_a, neighbors_b, shared_neighbors\r\nUNWIND neighbors_a AS neighbor_a \r\nSET neighbor_a.phase = coalesce(neighbor_a.phase, 0) + b.phase\r\n\r\nWITH a, b, neighbors_b, shared_neighbors\r\nUNWIND neighbors_b AS neighbor_b\r\nSET neighbor_b.phase = coalesce(neighbor_b.phase, 0) + a.phase\r\n\r\nWITH a, b, shared_neighbors\r\nUNWIND shared_neighbors AS shared_neighbor\r\nSET shared_neighbor.phase = coalesce(shared_neighbor.phase, 0) + a.phase + b.phase\r\n\r\nWITH DISTINCT a, b\r\nDETACH DELETE a, b\r\n\r\nRETURN COUNT(*) as pivot_operations_performed"
        },
        "params": {}
      },
      "style": {
        "code": {
          "value": "// A palette of colors used to color distinct node labels\nDefine(COLOR_PALETTE, AsArray(\n  #DD2222, #FB6E00, #FFC500, #720096,\n  #5E4FA2, #3288BD, #66C2A5, #ABDDA4,\n  #E6F598, #FEE08B, #D53E4F, #9E0142\n))\nDefine(COLOR_PALETTE_ITER, AsIterator(COLOR_PALETTE))\n\n// If there are no palette colors to use, use random colors instead\nDefine(RandomColor, Function(RGB(RandomInt(255), RandomInt(255), RandomInt(255))))\nDefine(GetNextColor, Function(\n  Coalesce(Next(COLOR_PALETTE_ITER), RandomColor())\n))\n\n// Cache map to keep a selected color for each node label\nDefine(ColorByLabel, AsMap())\nDefine(GetColorByLabel, Function(labels, Coalesce(\n  Get(ColorByLabel, labels),\n  Set(ColorByLabel, labels, GetNextColor())\n)))\nDefine(JoinLabels, Function(labels, Join(Sort(labels), \":\")))\n\n// Baseline node style that will be applied to every single node\n@NodeStyle {\n  Define(COLOR, GetColorByLabel(JoinLabels(Labels(node))))\n\n  size: 6\n  color: COLOR\n  color-hover: Lighter(COLOR)\n  color-selected: Darker(COLOR)\n  border-width: 0.6\n  border-color: #1D1D1D\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Overwrite node text with the node label if defined\n@NodeStyle Greater(Size(Labels(node)), 0) {\n  label: Format(\":{}\", Join(Labels(node), \" :\"))\n}\n\n// Overwrite node text with the property \"name\" if defined\n@NodeStyle HasProperty(node, \"name\") {\n  label: AsText(Property(node, \"name\"))\n}\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node label\n// @NodeStyle HasLabel(node, \"MyCustomLabel\") {\n//   color: black\n// }\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node property\n// @NodeStyle HasProperty(node, \"my_property_name\") {\n//   color: black\n//   label: AsText(Property(node, \"my_property_name\"))\n// }\n\nDefine(LATITUDE_FIELD, \"lat\")\nDefine(LONGITUDE_FIELD, \"lng\")\n\n// In the case of numeric latitude and longitude properties, set them up for a switch to a map view\n@NodeStyle And(IsNumber(Property(node, LATITUDE_FIELD)), IsNumber(Property(node, LONGITUDE_FIELD))) {\n  latitude: Property(node, LATITUDE_FIELD)\n  longitude: Property(node, LONGITUDE_FIELD)\n}\n\n// Baseline edge style that will be applied to every single edge\n@EdgeStyle {\n  color: #999999\n  color-hover: #1D1D1D\n  color-selected: #1D1D1D\n  width: 0.3\n  width-hover: 0.9\n  width-selected: 0.9\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Show edge text only if there is a small number of edges in the view\n@EdgeStyle Less(EdgeCount(graph), 30) {\n  label: Type(edge)\n}\n\n// In case of a map view, set the default tile layer\n@ViewStyle.Map {\n  tile-layer: \"light\"\n}\n\n// Canvas background color\n@ViewStyle {\n  background-color: #FFFFFF00\n}\n"
        },
        "title": "System Style"
      }
    },
    {
      "title": "Pivot rule - single interior Pauli spider",
      "description": "",
      "query": {
        "code": {
          "value": "// Interior Pauli spider removal rule - Memgraph compatible\r\nMATCH (a {t: 1})-[:Wire {t : 2}]-(b {t: 1})\r\nWHERE a.phase = round(a.phase) \r\n  AND b.phase = round(b.phase)\r\n  //AND id(a) < id(b)\r\n//RETURN a.id, b.id\r\n// Check b's connectivity: exactly one boundary (t=0) and one non-boundary\r\n//WITH a, b\r\n\r\nMATCH (b)-[:Wire]-(b_neighbor)\r\nWITH a, b, \r\n     COUNT(CASE WHEN b_neighbor.t = 0 THEN 1 END) as boundary_count,\r\n     COUNT(CASE WHEN b_neighbor.t <> 0 THEN 1 END) as non_boundary_count,\r\n     COLLECT(CASE WHEN b_neighbor.t = 0 THEN b_neighbor END)[0] as boundary_vertex\r\n\r\nWHERE boundary_count = 1 AND non_boundary_count = 1\r\n//RETURN a.id, b.id, boundary_vertex.id\r\n// Check that a is connected to at least one t=1 vertex with t=2 edge\r\nWITH a, b, boundary_vertex\r\nMATCH (a)-[a_edge:Wire {t: 2}]-(a_neighbor {t: 1})\r\nWITH a, b, boundary_vertex, COUNT(a_neighbor) as t1_neighbors_via_t2\r\nWHERE t1_neighbors_via_t2 > 0\r\n\r\n// Check that ALL edges from/to a have t=2\r\nWITH a, b, boundary_vertex\r\nMATCH (a)-[all_a_edges:Wire]-()\r\nWITH a, b, boundary_vertex,\r\n     COUNT(CASE WHEN all_a_edges.t <> 2 THEN 1 END) as non_t2_edges\r\nWHERE non_t2_edges = 0\r\n\r\n// Take only the first match\r\nWITH a, b, boundary_vertex\r\nLIMIT 1\r\n\r\n// Get the boundary edge type\r\nWITH a, b, boundary_vertex\r\nMATCH (b)-[boundary_edge:Wire]-(boundary_vertex)\r\n\r\n// Find all neighbors of a (excluding b) and update their phases\r\nWITH a, b, boundary_vertex, boundary_edge\r\nOPTIONAL MATCH (a)-[:Wire]-(a_neighbor)\r\nWHERE a_neighbor <> b AND a_neighbor.graph_id = a.graph_id\r\n\r\n// Use FOREACH to update phases (handles empty collections automatically)\r\nWITH a, b, boundary_vertex, boundary_edge, COLLECT(a_neighbor) as a_neighbors\r\nFOREACH (neighbor IN a_neighbors |\r\n  SET neighbor.phase = (coalesce(neighbor.phase, 0) + b.phase) % 2\r\n)\r\n\r\n// Connect a to boundary with opposite edge type\r\nWITH a, b, boundary_vertex, boundary_edge,\r\n     CASE boundary_edge.t WHEN 1 THEN 2 ELSE 1 END as new_edge_type\r\n\r\nCREATE (a)-[new_connection:Wire]->(boundary_vertex)\r\nSET new_connection.t = new_edge_type,\r\n    new_connection.graph_id = a.graph_id\r\n\r\n// Remove b\r\nDETACH DELETE b\r\n\r\nRETURN COUNT(*) as interior_pauli_removed"
        },
        "params": {}
      },
      "style": {
        "code": {
          "value": "// A palette of colors used to color distinct node labels\nDefine(COLOR_PALETTE, AsArray(\n  #DD2222, #FB6E00, #FFC500, #720096,\n  #5E4FA2, #3288BD, #66C2A5, #ABDDA4,\n  #E6F598, #FEE08B, #D53E4F, #9E0142\n))\nDefine(COLOR_PALETTE_ITER, AsIterator(COLOR_PALETTE))\n\n// If there are no palette colors to use, use random colors instead\nDefine(RandomColor, Function(RGB(RandomInt(255), RandomInt(255), RandomInt(255))))\nDefine(GetNextColor, Function(\n  Coalesce(Next(COLOR_PALETTE_ITER), RandomColor())\n))\n\n// Cache map to keep a selected color for each node label\nDefine(ColorByLabel, AsMap())\nDefine(GetColorByLabel, Function(labels, Coalesce(\n  Get(ColorByLabel, labels),\n  Set(ColorByLabel, labels, GetNextColor())\n)))\nDefine(JoinLabels, Function(labels, Join(Sort(labels), \":\")))\n\n// Baseline node style that will be applied to every single node\n@NodeStyle {\n  Define(COLOR, GetColorByLabel(JoinLabels(Labels(node))))\n\n  size: 6\n  color: COLOR\n  color-hover: Lighter(COLOR)\n  color-selected: Darker(COLOR)\n  border-width: 0.6\n  border-color: #1D1D1D\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Overwrite node text with the node label if defined\n@NodeStyle Greater(Size(Labels(node)), 0) {\n  label: Format(\":{}\", Join(Labels(node), \" :\"))\n}\n\n// Overwrite node text with the property \"name\" if defined\n@NodeStyle HasProperty(node, \"name\") {\n  label: AsText(Property(node, \"name\"))\n}\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node label\n// @NodeStyle HasLabel(node, \"MyCustomLabel\") {\n//   color: black\n// }\n\n// Feel free to uncomment the lines below to set up a custom style for the specific node property\n// @NodeStyle HasProperty(node, \"my_property_name\") {\n//   color: black\n//   label: AsText(Property(node, \"my_property_name\"))\n// }\n\nDefine(LATITUDE_FIELD, \"lat\")\nDefine(LONGITUDE_FIELD, \"lng\")\n\n// In the case of numeric latitude and longitude properties, set them up for a switch to a map view\n@NodeStyle And(IsNumber(Property(node, LATITUDE_FIELD)), IsNumber(Property(node, LONGITUDE_FIELD))) {\n  latitude: Property(node, LATITUDE_FIELD)\n  longitude: Property(node, LONGITUDE_FIELD)\n}\n\n// Baseline edge style that will be applied to every single edge\n@EdgeStyle {\n  color: #999999\n  color-hover: #1D1D1D\n  color-selected: #1D1D1D\n  width: 0.3\n  width-hover: 0.9\n  width-selected: 0.9\n  font-size: 3\n  font-color: #1D1D1D\n}\n\n// Show edge text only if there is a small number of edges in the view\n@EdgeStyle Less(EdgeCount(graph), 30) {\n  label: Type(edge)\n}\n\n// In case of a map view, set the default tile layer\n@ViewStyle.Map {\n  tile-layer: \"light\"\n}\n\n// Canvas background color\n@ViewStyle {\n  background-color: #FFFFFF00\n}\n"
        },
        "title": "System Style"
      }
    }
  ]
}